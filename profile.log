FUNCTION  3()
Called 160 times
Total time:   0.009954
 Self time:   0.006954

count  total (s)   self (s)
  160   0.003096   0.001114     let self.cachedDisplayString = g:NERDTreeNodeDelimiter . self.getLastPathComponent(1)
                            
  160              0.000191     if self.isExecutable
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . '*'
                                endif
                            
  160              0.000388     let self._bookmarkNames = []
  160   0.001762   0.000744     for i in g:NERDTreeBookmark.Bookmarks()
                                    if i.path.equals(self)
                                        call add(self._bookmarkNames, i.name)
                                    endif
                                endfor
  160              0.000410     if !empty(self._bookmarkNames) && g:NERDTreeMarkBookmarks == 1
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' {' . join(self._bookmarkNames) . '}'
                                endif
                            
  160              0.000183     if self.isSymLink
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' -> ' . self.symLinkDest
                                endif
                            
  160              0.000174     if self.isReadOnly
                                    let self.cachedDisplayString = self.addDelimiter(self.cachedDisplayString) . ' ['.g:NERDTreeGlyphReadOnly.']'
                                endif

FUNCTION  AutoPairsSpace()
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    1              0.000005   let line = getline('.')
    1              0.000004   let prev_char = line[col('.')-2]
    1              0.000001   let cmd = ''
    1              0.000003   let cur_char =line[col('.')-1]
    1              0.000006   if has_key(g:AutoPairsParens, prev_char) && g:AutoPairsParens[prev_char] == cur_char
                                let cmd = "\<SPACE>".s:Left
                              endif
    1              0.000004   return "\<SPACE>".cmd

FUNCTION  <SNR>310_Pop()
Called 2 times
Total time:   0.000258
 Self time:   0.000100

count  total (s)   self (s)
    2   0.000027   0.000008 	if s:EmptystackP(a:sname)
                            		return ''
                            	endif
    2              0.000007 	exe 'let stack='.a:sname
    2   0.000087   0.000011 	call s:SetKeywords()
    2              0.000025 	let loc=matchend(stack,'\<.\{-1,}\>')
    2              0.000015 	exe 'let '.a:sname.'=strpart(stack, loc+1, strlen(stack))'
    2              0.000012 	let top=strpart(stack, match(stack, '\<'), loc)
    2   0.000076   0.000012 	call s:RestoreKeywords()
    2              0.000003 	return top

FUNCTION  airline#extensions#ale#get_error()
Called 213 times
Total time:   0.011837
 Self time:   0.001022

count  total (s)   self (s)
  213   0.011749   0.000934   return airline#extensions#ale#get('error')

FUNCTION  gitgutter#utility#repo_path()
Called 3 times
Total time:   0.000055
 Self time:   0.000020

count  total (s)   self (s)
    3   0.000032   0.000011   let p = gitgutter#utility#getbufvar(a:bufnr, 'path')
    3   0.000021   0.000007   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  ale#linter#Get()
Called 7 times
Total time:   0.010023
 Self time:   0.006947

count  total (s)   self (s)
    7              0.000028     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   35              0.000144     for l:original_filetype in split(a:original_filetypes, '\.')
   28   0.000955   0.000197         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   28   0.000549   0.000163         let l:linter_names = s:GetLinterNames(l:original_filetype)
   28   0.002094   0.000163         let l:all_linters = ale#linter#GetAll(l:filetype)
   28              0.000054         let l:filetype_linters = []
                            
   28              0.000084         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
                                        let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
  280              0.000297             for l:linter in l:all_linters
  252              0.000803                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
  448              0.000550                 for l:name in l:name_list
  252              0.000597                     if index(l:linter_names, l:name) >= 0
   56              0.000133                         call add(l:filetype_linters, l:linter)
   56              0.000050                         break
                                                endif
  196              0.000135                 endfor
  252              0.000168             endfor
   28              0.000022         endif
                            
   28              0.000086         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   28              0.000020     endfor
                            
    7              0.000012     let l:name_list = []
    7              0.000013     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   63              0.000078     for l:linter in reverse(l:possibly_duplicated_linters)
   56              0.000133         if index(l:name_list, l:linter.name) < 0
   14              0.000035             call add(l:name_list, l:linter.name)
   14              0.000031             call add(l:combined_linters, l:linter)
   14              0.000009         endif
   56              0.000036     endfor
                            
    7              0.000015     return reverse(l:combined_linters)

FUNCTION  deoplete#handler#_async_timer_stop()
Called 21 times
Total time:   0.000282
 Self time:   0.000282

count  total (s)   self (s)
   21              0.000070   if exists('s:async_timer')
   17              0.000077     call timer_stop(s:async_timer.id)
   17              0.000058     unlet s:async_timer
   17              0.000020   endif

FUNCTION  airline#check_mode()
Called 245 times
Total time:   0.499605
 Self time:   0.028659

count  total (s)   self (s)
  245              0.000719   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
  245              0.000797   let context = s:contexts[a:winnr]
                            
  245              0.000667   if get(w:, 'airline_active', 1)
  220              0.000601     let l:m = mode(1)
  220              0.000372     if l:m ==# "i"
  140              0.000310       let l:mode = ['insert']
  140              0.000208     elseif l:m[0] ==# "i"
   51              0.000099       let l:mode = ['insert']
   51              0.000051     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
    4              0.000018       let l:mode = ['commandline']
    4              0.000009     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
   25              0.000052       let l:mode = ['normal']
   25              0.000019     endif
  220              0.001042     if index(['Rv', 'no', 'ni', 'ix', 'ic'], l:m) == -1
  169              0.000369       let l:m = l:m[0]
  169              0.000118     endif
  220              0.001008     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  220              0.000167   else
   25              0.000067     let l:mode = ['inactive']
   25              0.000128     let w:airline_current_mode = get(g:airline_mode_map, '__')
   25              0.000022   endif
                            
  245              0.000775   if g:airline_detect_modified && &modified
  200              0.000638     call add(l:mode, 'modified')
  200              0.000145   endif
                            
  245              0.000450   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
  245              0.002484   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
  245              0.000553   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
  245              0.000448   if &readonly || ! &modifiable
   32              0.000101     call add(l:mode, 'readonly')
   32              0.000023   endif
                            
  245              0.001131   let mode_string = join(l:mode)
  245              0.000818   if get(w:, 'airline_lastmode', '') != mode_string
   10   0.006851   0.000157     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   10   0.463909   0.000149     call airline#highlighter#highlight(l:mode, context.bufnr)
   10   0.000544   0.000053     call airline#util#doautocmd('AirlineModeChanged')
   10              0.000038     let w:airline_lastmode = mode_string
   10              0.000007   endif
                            
  245              0.000253   return ''

FUNCTION  <SNR>51_dir()
Called 5 times
Total time:   0.000285
 Self time:   0.000050

count  total (s)   self (s)
    5   0.000282   0.000047   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  <SNR>115_section_is_empty()
Called 4 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    4              0.000011   let start=1
                            
                              " do not check for inactive windows or the tabline
    4              0.000012   if a:self._context.active == 0
                                return 0
                              elseif get(a:self._context, 'tabline', 0)
                                return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
    4              0.000017   if get(g:, 'airline_skip_empty_sections', 0) == 0
    4              0.000006     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  <SNR>131_HandleExit()
Called 7 times
Total time:   0.008920
 Self time:   0.000150

count  total (s)   self (s)
    7              0.000032     if !has_key(s:job_info_map, a:job_id)
    6              0.000006         return
                                endif
                            
    1              0.000002     let l:job_info = s:job_info_map[a:job_id]
    1              0.000002     let l:linter = l:job_info.linter
    1              0.000001     let l:output = l:job_info.output
    1              0.000001     let l:buffer = l:job_info.buffer
    1              0.000002     let l:executable = l:job_info.executable
    1              0.000002     let l:next_chain_index = l:job_info.next_chain_index
                            
    1              0.000001     if g:ale_history_enabled
    1   0.000039   0.000008         call ale#history#SetExitCode(l:buffer, a:job_id, a:exit_code)
    1              0.000001     endif
                            
                                " Remove this job from the list.
    1   0.000030   0.000004     call ale#job#Stop(a:job_id)
    1              0.000003     call remove(s:job_info_map, a:job_id)
    1              0.000005     call filter(g:ale_buffer_info[l:buffer].job_list, 'v:val isnot# a:job_id')
    1              0.000004     call filter(g:ale_buffer_info[l:buffer].active_linter_list, 'v:val isnot# l:linter.name')
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    1   0.000024   0.000003     if ale#util#InSandbox()
                                    return
                                endif
                            
    1              0.000005     if has('nvim') && !empty(l:output) && empty(l:output[-1])
                                    call remove(l:output, -1)
                                endif
                            
    1              0.000003     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    call s:InvokeChain(l:buffer, l:executable, l:linter, l:next_chain_index, l:output)
                            
                                    return
                                endif
                            
                                " Log the output of the command for ALEInfo if we should.
    1              0.000002     if g:ale_history_enabled && g:ale_history_log_output
    1   0.000034   0.000013         call ale#history#RememberOutput(l:buffer, a:job_id, l:output[:])
    1              0.000001     endif
                            
    1              0.000001     try
    1   0.002565   0.000013         let l:loclist = ale#util#GetFunction(l:linter.callback)(l:buffer, l:output)
                                " Handle the function being unknown, or being deleted.
    1              0.000001     catch /E700/
                                    let l:loclist = []
                                endtry
                            
    1   0.006131   0.000011     call ale#engine#HandleLoclist(l:linter.name, l:buffer, l:loclist, 0)

FUNCTION  <SNR>112_Get()
Called 1869 times
Total time:   0.010233
 Self time:   0.010233

count  total (s)   self (s)
 1869              0.004366   let res=get(a:dict, a:key, '')
 1869              0.001752   if res is ''
  808              0.000532     return ''
                              else
 1061              0.001397     return a:prefix. res
                              endif

FUNCTION  airline#extensions#branch#update_untracked_config()
Called 213 times
Total time:   0.002793
 Self time:   0.002793

count  total (s)   self (s)
  213              0.000728   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
                              elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
                              endif

FUNCTION  <SNR>107_check_mixed_indent_file()
Called 1 time
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    1              0.000004   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    1              0.000004   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
                                let head_spc = '\v(^ +\*@!)'
                              else
    1              0.000001     let head_spc = '\v(^ +)'
    1              0.000000   endif
    1              0.000005   let indent_tabs = search('\v(^\t+)', 'nw')
    1              0.000004   let indent_spc  = search(head_spc, 'nw')
    1              0.000001   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
                              else
    1              0.000001     return ''
                              endif

FUNCTION  ale#handlers#eslint#Handle()
Called 1 time
Total time:   0.002547
 Self time:   0.000574

count  total (s)   self (s)
    1   0.000386   0.000007     if s:CheckForBadConfig(a:buffer, a:lines)
                                    return [{   'lnum': 1,   'text': 'eslint configuration error (type :ALEDetail for more information)',   'detail': join(a:lines, "\n"),}]
                                endif
                            
    1              0.000002     if a:lines == ['Could not connect']
                                    return [{   'lnum': 1,   'text': 'Could not connect to eslint_d. Try updating eslint_d or killing it.',}]
                                endif
                            
                                " Matches patterns line the following:
                                "
                                " /path/to/some-filename.js:47:14: Missing trailing comma. [Warning/comma-dangle]
                                " /path/to/some-filename.js:56:41: Missing semicolon. [Error/semi]
    1              0.000002     let l:pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\) \[\(.\+\)\]$'
                                " This second pattern matches lines like the following:
                                "
                                " /path/to/some-filename.js:13:3: Parsing error: Unexpected token
    1              0.000002     let l:parsing_pattern = '^.*:\(\d\+\):\(\d\+\): \(.\+\)$'
    1              0.000001     let l:output = []
                            
   16   0.000532   0.000026     for l:match in ale#util#GetMatches(a:lines, [l:pattern, l:parsing_pattern])
   15              0.000021         let l:text = l:match[3]
                            
   15   0.000174   0.000052         if ale#Var(a:buffer, 'javascript_eslint_suppress_eslintignore')
                                        if l:text is# 'File ignored because of a matching ignore pattern. Use "--no-ignore" to override.'
                                            continue
                                        endif
                                    endif
                            
   15              0.000056         let l:obj = {   'lnum': l:match[1] + 0,   'col': l:match[2] + 0,   'text': l:text,   'type': 'E',}
                            
                                    " Take the error type from the output if available.
   15              0.000049         let l:split_code = split(l:match[4], '/')
                            
   15              0.000025         if get(l:split_code, 0, '') is# 'Warning'
                                        let l:obj.type = 'W'
                                    endif
                            
                                    " The code can be something like 'Error/foo/bar', or just 'Error'
   15              0.000026         if !empty(get(l:split_code, 1))
   15              0.000042             let l:obj.code = join(l:split_code[1:], '/')
   15              0.000007         endif
                            
   15   0.001029   0.000061         for l:col_match in ale#util#GetMatches(l:text, s:col_end_patterns)
                                        let l:obj.end_col = l:obj.col + len(l:col_match[1]) - 1
                                    endfor
                            
   15              0.000023         call add(l:output, l:obj)
   15              0.000007     endfor
                            
    1              0.000006     if expand('#' . a:buffer . ':t') =~? '\.tsx\?$'
                                    call s:AddHintsForTypeScriptParsingErrors(l:output)
                                endif
                            
    1              0.000001     return l:output

FUNCTION  <SNR>163_ApplyPartialTimer()
Called 1 time
Total time:   0.001015
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000002     if has_key(s:partial_timers, a:timer_id)
    1              0.000005         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    1   0.001007   0.000009         call call(l:Callback, [a:timer_id] + l:args)
    1              0.000000     endif

FUNCTION  <SNR>159_build_command()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000002   if has('unix')
    1              0.000003     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  ale#sign#FindCurrentSigns()
Called 1 time
Total time:   0.000296
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000037   0.000006     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
    1   0.000258   0.000006     return ale#sign#ParseSigns(l:line_list)

FUNCTION  <SNR>161_process_hunk()
Called 3 times
Total time:   0.000454
 Self time:   0.000190

count  total (s)   self (s)
    3              0.000004   let modifications = []
    3              0.000005   let from_line  = a:hunk[0]
    3              0.000004   let from_count = a:hunk[1]
    3              0.000004   let to_line    = a:hunk[2]
    3              0.000004   let to_count   = a:hunk[3]
                            
    3   0.000017   0.000012   if s:is_added(from_count, to_count)
    1   0.000031   0.000007     call s:process_added(modifications, from_count, to_count, to_line)
    1   0.000033   0.000003     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    1              0.000002   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
                              elseif s:is_modified(from_count, to_count)
                                call s:process_modified(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
                              elseif s:is_modified_and_added(from_count, to_count)
    1   0.000056   0.000008     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    1   0.000046   0.000007     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    1   0.000038   0.000007     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
    1              0.000002   elseif s:is_modified_and_removed(from_count, to_count)
    1   0.000024   0.000007     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    1   0.000034   0.000004     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    1   0.000035   0.000007     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    1              0.000000   endif
    3              0.000002   return modifications

FUNCTION  <SNR>51_is_file_buffer()
Called 7 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    7              0.000030   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  deoplete#util#get_input()
Called 112 times
Total time:   0.007772
 Self time:   0.007772

count  total (s)   self (s)
  112              0.000357   let mode = mode()
  112              0.000251   if a:event ==# 'InsertEnter'
    2              0.000006     let mode = 'i'
    2              0.000003   endif
  112              0.001911   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
  112              0.001455   if input =~# '^.\{-}\ze\S\+$'
   80              0.000795     let complete_str = matchstr(input, '\S\+$')
   80              0.000770     let input = matchstr(input, '^.\{-}\ze\S\+$')
   80              0.000087   else
   32              0.000074     let complete_str = ''
   32              0.000031   endif
                            
  112              0.000233   if a:event ==# 'InsertCharPre'
   21              0.000060     let complete_str .= v:char
   21              0.000016   endif
                            
  112              0.000304   return input . complete_str

FUNCTION  <SNR>49_NERDTreeGetIndicator()
Called 160 times
Total time:   0.002809
 Self time:   0.002809

count  total (s)   self (s)
  160              0.000456     if exists('g:NERDTreeIndicatorMapCustom')
                                    let l:indicator = get(g:NERDTreeIndicatorMapCustom, a:statusKey, '')
                                    if l:indicator !=# ''
                                        return l:indicator
                                    endif
                                endif
  160              0.000617     let l:indicator = get(s:NERDTreeIndicatorMap, a:statusKey, '')
  160              0.000256     if l:indicator !=# ''
   84              0.000122         return l:indicator
                                endif
   76              0.000054     return ''

FUNCTION  ale#sign#GetSignName()
Called 10 times
Total time:   0.000403
 Self time:   0.000219

count  total (s)   self (s)
   10              0.000016     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
   25              0.000020     for l:item in a:sublist
   15   0.000237   0.000054         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
   15              0.000016         if l:item_priority > l:priority
   10              0.000012             let l:priority = l:item_priority
   10              0.000004         endif
   15              0.000007     endfor
                            
   10              0.000012     if l:priority is# g:ale#util#error_priority
   10              0.000007         return 'ALEErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#warning_priority
                                    return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  <SNR>59_cursorhold_callback()
Called 1 time
Total time:   0.000051
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000047   0.000003   call s:echo()
    1              0.000003   autocmd! bufferline CursorHold

FUNCTION  <SNR>51_not_git_dir()
Called 4 times
Total time:   0.000316
 Self time:   0.000072

count  total (s)   self (s)
    4   0.000314   0.000070   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  airline#util#has_fugitive()
Called 213 times
Total time:   0.000725
 Self time:   0.000725

count  total (s)   self (s)
  213              0.000634   return exists('*fugitive#head') || exists('*FugitiveHead')

FUNCTION  ale#job#Start()
Called 7 times
Total time:   0.012485
 Self time:   0.012423

count  total (s)   self (s)
    7   0.000103   0.000042     call ale#job#ValidateArguments(a:command, a:options)
                            
    7              0.000035     let l:job_info = copy(a:options)
    7              0.000016     let l:job_options = {}
                            
    7              0.000021     if has('nvim')
    7              0.000017         if has_key(a:options, 'out_cb')
    7              0.000032             let l:job_options.on_stdout = function('s:NeoVimCallback')
    7              0.000014             let l:job_info.out_cb_line = ''
    7              0.000005         endif
                            
    7              0.000014         if has_key(a:options, 'err_cb')
    7              0.000025             let l:job_options.on_stderr = function('s:NeoVimCallback')
    7              0.000012             let l:job_info.err_cb_line = ''
    7              0.000004         endif
                            
    7              0.000015         if has_key(a:options, 'exit_cb')
    7              0.000027             let l:job_options.on_exit = function('s:NeoVimCallback')
    7              0.000004         endif
                            
    7              0.011587         let l:job_info.job = jobstart(a:command, l:job_options)
    7              0.000054         let l:job_id = l:job_info.job
    7              0.000008     else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
                                endif
                            
    7              0.000014     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    7              0.000044         let s:job_map[l:job_id] = l:job_info
    7              0.000005     endif
                            
    7              0.000018     return l:job_id

FUNCTION  airline#parts#filetype()
Called 213 times
Total time:   0.001100
 Self time:   0.001100

count  total (s)   self (s)
  213              0.001001   return winwidth(0) < 90 && strlen(&filetype) > 3 ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000011   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
                              endif

FUNCTION  airline#parts#iminsert()
Called 213 times
Total time:   0.001242
 Self time:   0.001242

count  total (s)   self (s)
  213              0.000509   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
  213              0.000146   return ''

FUNCTION  airline#parts#spell()
Called 213 times
Total time:   0.005149
 Self time:   0.005149

count  total (s)   self (s)
  213              0.002218   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  213              0.000464   if g:airline_detect_spell && &spell
                                if winwidth(0) >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth(0) >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
  213              0.000172   return ''

FUNCTION  <SNR>159_on_stdout_nvim()
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000005   if empty(self.stdoutbuffer)
    1              0.000002     let self.stdoutbuffer = a:data
    1              0.000001   else
    1              0.000009     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
    1              0.000001   endif

FUNCTION  gitgutter#async#execute()
Called 1 time
Total time:   0.001968
 Self time:   0.001935

count  total (s)   self (s)
    1   0.000040   0.000013   call gitgutter#debug#log('[async] '.a:cmd)
                            
    1              0.000004   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    1   0.000012   0.000007   let command = s:build_command(a:cmd)
                            
    1              0.000002   if has('nvim')
    1              0.001891     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
    1              0.000003   else
                                call job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                              endif

FUNCTION  <SNR>164_GetLinterNames()
Called 28 times
Total time:   0.000386
 Self time:   0.000386

count  total (s)   self (s)
   28              0.000115     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   28              0.000050     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
   28              0.000068     if type(l:buffer_ale_linters) is v:t_list
   28              0.000041         return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
                                if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
                                if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
                                if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
                                if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
                                return 'all'

FUNCTION  <SNR>125_completion_timer_start()
Called 23 times
Total time:   0.002491
 Self time:   0.001109

count  total (s)   self (s)
   23              0.000125   if exists('s:completion_timer')
   23   0.000511   0.000169     call s:completion_timer_stop()
   23              0.000020   endif
                            
   23   0.001300   0.000260   let delay = deoplete#custom#_get_option('auto_complete_delay')
   23              0.000045   if delay > 0
   23              0.000308     let s:completion_timer = timer_start( delay, {-> s:completion_begin(a:event)})
   23              0.000024   else
                                call s:completion_begin(a:event)
                              endif

FUNCTION  <SNR>127_TagbarBufName()
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000005     if !exists('t:tagbar_buf_name')
                                    let s:buffer_seqno += 1
                                    let t:tagbar_buf_name = '__Tagbar__.' . s:buffer_seqno
                                endif
                            
    2              0.000002     return t:tagbar_buf_name

FUNCTION  ale#events#ReadOrEnterEvent()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
    1              0.000004     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
                                endif
                            
                                " When entering a buffer, we are no longer quitting it.
    1              0.000004     call setbufvar(a:buffer, 'ale_quitting', 0)
    1              0.000003     let l:filetype = getbufvar(a:buffer, '&filetype')
    1              0.000004     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
    1              0.000002     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
                                endif

FUNCTION  deoplete#util#get_next_input()
Called 37 times
Total time:   0.002686
 Self time:   0.000377

count  total (s)   self (s)
   37   0.002650   0.000341   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  <SNR>184_ShouldOpen()
Called 2 times
Total time:   0.000032
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000022   0.000007     let l:val = ale#Var(a:buffer, 'open_list')
    2              0.000005     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    2              0.000003     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  deoplete#init#_context()
Called 37 times
Total time:   0.095754
 Self time:   0.077825

count  total (s)   self (s)
   37   0.002594   0.000257   let input = deoplete#util#get_input(a:event)
                            
   37   0.005135   0.000484   let [filetype, filetypes, same_filetypes] = deoplete#util#get_context_filetype(input, a:event)
                            
   37   0.000501   0.000279   let sources = deoplete#util#convert2list(a:sources)
   37              0.000136   if a:event !=# 'Manual' && empty(sources)
                                " Use default sources
   37   0.003429   0.000338     let sources = deoplete#custom#_get_filetype_option( 'sources', filetype, [])
   37              0.000036   endif
                            
   37   0.000484   0.000302   let event = (deoplete#util#get_prev_event() ==# 'Refresh') ? 'Manual' : a:event
                            
   37              0.000547   let width = winwidth(0) - col('.') + len(matchstr(input, '\w*$'))
   37              0.000140   let max_width = (width * 2 / 3)
                            
   37              0.000304   let bufnr = expand('<abuf>') !=# '' ? expand('<abuf>') : bufnr('%')
   37              0.000258   let bufname = bufname(bufnr)
   37              0.001072   let bufpath = fnamemodify(bufname, ':p')
   37              0.000699   if !filereadable(bufpath) || getbufvar(bufnr, '&buftype') =~# 'nofile'
    1              0.000003     let bufpath = ''
    1              0.000001   endif
                            
   37   0.079933   0.072487   return { 'changedtick': b:changedtick, 'event': event, 'input': input, 'is_windows': s:is_windows, 'next_input': deoplete#util#get_next_input(a:event), 'complete_str': '', 'encoding': &encoding, 'position': getpos('.'), 'filetype': filetype, 'filetypes': filetypes, 'same_filetypes': same_filetypes, 'ignorecase': deoplete#custom#_get_option('ignore_case'), 'smartcase': deoplete#custom#_get_option('smart_case'), 'camelcase': deoplete#custom#_get_option('camel_case'), 'sources': sources, 'max_abbr_width': max_width, 'max_kind_width': max_width, 'max_menu_width': max_width, 'bufnr': bufnr, 'bufname': bufname, 'bufpath': bufpath, 'cwd': getcwd(), 'vars': filter(copy(g:),       "stridx(v:key, 'deoplete#') == 0        && v:key !=# 'deoplete#_yarp'"), 'custom': deoplete#custom#_get(), 'omni__omnifunc': &l:omnifunc, }

FUNCTION  ale#engine#ManageDirectory()
Called 7 times
Total time:   0.000175
 Self time:   0.000080

count  total (s)   self (s)
    7   0.000127   0.000031     call ale#engine#InitBufferInfo(a:buffer)
    7              0.000042     call add(g:ale_buffer_info[a:buffer].temporary_directory_list, a:directory)

FUNCTION  ale#Var()
Called 73 times
Total time:   0.000939
 Self time:   0.000939

count  total (s)   self (s)
   73              0.000194     let l:full_name = 'ale_' . a:variable_name
   73              0.000380     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   73              0.000285     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  <SNR>184_CloseWindowIfNeeded()
Called 1 time
Total time:   0.000029
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000028   0.000005     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    1              0.000001         return
                                endif
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                        endif
                                    else
                                        let l:win_id = s:BufWinId(a:buffer)
                            
                                        if g:ale_set_loclist && empty(getloclist(l:win_id))
                                            lclose
                                        endif
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry

FUNCTION  <SNR>106_airline_ale_count()
Called 112 times
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
  112              0.000179   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  <SNR>131_RunJob()
Called 7 times
Total time:   0.018344
 Self time:   0.001547

count  total (s)   self (s)
    7              0.000019     let l:command = a:options.command
                            
    7              0.000014     if empty(l:command)
                                    return 0
                                endif
                            
    7              0.000016     let l:executable = a:options.executable
    7              0.000013     let l:buffer = a:options.buffer
    7              0.000012     let l:linter = a:options.linter
    7              0.000015     let l:output_stream = a:options.output_stream
    7              0.000016     let l:next_chain_index = a:options.next_chain_index
    7              0.000015     let l:read_buffer = a:options.read_buffer
    7              0.000022     let l:info = g:ale_buffer_info[l:buffer]
                            
    7   0.001288   0.000075     let [l:temporary_file, l:command] = ale#command#FormatCommand(   l:buffer,   l:executable,   l:command,   l:read_buffer,)
                            
    7   0.001291   0.000058     if s:CreateTemporaryFileForJob(l:buffer, l:temporary_file)
                                    " If a temporary filename has been formatted in to the command, then
                                    " we do not need to send the Vim buffer to the command.
    7              0.000017         let l:read_buffer = 0
    7              0.000005     endif
                            
                                " Add a newline to commands which need it.
                                " This is only used for Flow for now, and is not documented.
    7              0.000011     if l:linter.add_newline
                                    if has('win32')
                                        let l:command = l:command . '; echo.'
                                    else
                                        let l:command = l:command . '; echo'
                                    endif
                                endif
                            
    7   0.000851   0.000065     let l:command = ale#job#PrepareCommand(l:buffer, l:command)
    7              0.000058     let l:job_options = {   'mode': 'nl',   'exit_cb': function('s:HandleExit'),}
                            
    7              0.000013     if l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput')
                                elseif l:output_stream is# 'both'
    7              0.000033         let l:job_options.out_cb = function('s:GatherOutput')
    7              0.000024         let l:job_options.err_cb = function('s:GatherOutput')
    7              0.000005     else
                                    let l:job_options.out_cb = function('s:GatherOutput')
                                endif
                            
    7              0.000019     if get(g:, 'ale_run_synchronously') == 1
                                    " Find a unique Job value to use, which will be the same as the ID for
                                    " running commands synchronously. This is only for test code.
                                    let l:job_id = len(s:job_info_map) + 1
                            
                                    while has_key(s:job_info_map, l:job_id)
                                        let l:job_id += 1
                                    endwhile
                                else
    7   0.012592   0.000108         let l:job_id = ale#job#Start(l:command, l:job_options)
    7              0.000011     endif
                            
    7              0.000015     let l:status = 'failed'
                            
                                " Only proceed if the job is being run.
    7              0.000008     if l:job_id
                                    " Add the job to the list of jobs, so we can track them.
    7              0.000046         call add(l:info.job_list, l:job_id)
                            
    7              0.000040         if index(l:info.active_linter_list, l:linter.name) < 0
    7              0.000033             call add(l:info.active_linter_list, l:linter.name)
    7              0.000006         endif
                            
    7              0.000013         let l:status = 'started'
                                    " Store the ID for the job in the map to read back again.
    7              0.000121         let s:job_info_map[l:job_id] = {   'linter': l:linter,   'buffer': l:buffer,   'executable': l:executable,   'output': [],   'next_chain_index': l:next_chain_index,}
                            
    7   0.000640   0.000096         silent doautocmd <nomodeline> User ALEJobStarted
    7              0.000005     endif
                            
    7              0.000011     if g:ale_history_enabled
    7   0.000610   0.000073         call ale#history#Add(l:buffer, l:status, l:job_id, l:command)
    7              0.000004     endif
                            
    7              0.000021     if get(g:, 'ale_run_synchronously') == 1
                                    " Run a command synchronously if this test option is set.
                                    let s:job_info_map[l:job_id].output = systemlist(   type(l:command) is v:t_list   ?  join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])   : l:command)
                            
                                    call l:job_options.exit_cb(l:job_id, v:shell_error)
                                endif
                            
    7              0.000011     return l:job_id != 0

FUNCTION  <SNR>121_vimoption2python()
Called 34 times
Total time:   0.010277
 Self time:   0.006174

count  total (s)   self (s)
   34              0.000076   let has_dash = 0
   34              0.000054   let patterns = []
  214              0.000497   for pattern in split(a:option, ',')
  180              0.000645     if pattern =~# '\d\+'
   67              0.000878       let pattern = substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g')
   67              0.000050     endif
                            
  180              0.000251     if pattern ==# ''
                                  " ,
    2              0.000002       call add(patterns, ',')
    2              0.000001     elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
    1              0.000001       let has_dash = 1
    1              0.000000     else
  177              0.000461       call add(patterns, pattern)
  177              0.000111     endif
  180              0.000161   endfor
                            
                              " Dash must be last.
   34              0.000046   if has_dash
    1              0.000001     call add(patterns, '-')
    1              0.000000   endif
                            
   34   0.004450   0.000347   return join(deoplete#util#uniq(patterns), '')

FUNCTION  gitgutter#utility#cd_cmd()
Called 1 time
Total time:   0.000101
 Self time:   0.000019

count  total (s)   self (s)
    1   0.000053   0.000012   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() ? 'cd /d' : 'cd')
    1   0.000047   0.000006   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>51_winshell()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>161_is_added()
Called 3 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    3              0.000004   return a:from_count == 0 && a:to_count > 0

FUNCTION  htmlcomplete#CompleteTags()
Called 26 times
Total time:   0.031354
 Self time:   0.019105

count  total (s)   self (s)
   26              0.000060   if a:findstart
                                " locate the start of the word
   14              0.000047     let line = getline('.')
   14              0.000040     let start = col('.') - 1
   14              0.000037 	let curline = line('.')
   14              0.000034 	let compl_begin = col('.') - 2
   40              0.000294     while start >= 0 && line[start - 1] =~ '\(\k\|[!:.-]\)'
   26              0.000048 		let start -= 1
   26              0.000026     endwhile
                            	" Handling of entities {{{
   14              0.000052 	if start >= 0 && line[start - 1] =~ '&'
                            		let b:entitiescompl = 1
                            		let b:compl_context = ''
                            		return start
                            	endif
                            	" }}}
                            	" Handling of <style> tag {{{
   14              0.000245 	let stylestart = searchpair('<style\>', '', '<\/style\>', "bnW")
   14              0.000389 	let styleend   = searchpair('<style\>', '', '<\/style\>', "nW")
   14              0.000030 	if stylestart != 0 && styleend != 0
                            		if stylestart <= curline && styleend >= curline
                            			let start = col('.') - 1
                            			let b:csscompl = 1
                            			while start >= 0 && line[start - 1] =~ '\(\k\|-\)'
                            				let start -= 1
                            			endwhile
                            		endif
                            	endif
                            	" }}}
                            	" Handling of <script> tag {{{
   14              0.000153 	let scriptstart = searchpair('<script\>', '', '<\/script\>', "bnW")
   14              0.000244 	let scriptend   = searchpair('<script\>', '', '<\/script\>', "nW")
   14              0.000028 	if scriptstart != 0 && scriptend != 0
                            		if scriptstart <= curline && scriptend >= curline
                            			let start = col('.') - 1
                            			let b:jscompl = 1
                            			let b:jsrange = [scriptstart, scriptend]
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            			" We are inside of <script> tag. But we should also get contents
                            			" of all linked external files and (secondary, less probably) other <script> tags
                            			" This logic could possible be done in separate function - may be
                            			" reused in events scripting (also with option could be reused for
                            			" CSS
                            			let b:js_extfiles = []
                            			let l = line('.')
                            			let c = col('.')
                            			call cursor(1,1)
                            			while search('<\@<=script\>', 'W') && line('.') <= l
                            				if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            					let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            					if filereadable(sname)
                            						let b:js_extfiles += readfile(sname)
                            					endif
                            				endif
                            			endwhile
                            			call cursor(1,1)
                            			let js_scripttags = []
                            			while search('<script\>', 'W') && line('.') < l
                            				if matchstr(getline('.'), '<script[^>]*src') == ''
                            					let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            					let js_scripttags += js_scripttag
                            				endif
                            			endwhile
                            			let b:js_extfiles += js_scripttags
                            			call cursor(l,c)
                            			unlet! l c
                            		endif
                            	endif
                            	" }}}
   14              0.000060 	if !exists("b:csscompl") && !exists("b:jscompl")
   14              0.000069 		let b:compl_context = getline('.')[0:(compl_begin)]
   14              0.000109 		if b:compl_context !~ '<[^>]*$'
                            			" Look like we may have broken tag. Check previous lines.
                            			let i = 1
                            			while 1
                            				let context_line = getline(curline-i)
                            				if context_line =~ '<[^>]*$'
                            					" Yep, this is this line
                            					let context_lines = getline(curline-i, curline-1) + [b:compl_context]
                            					let b:compl_context = join(context_lines, ' ')
                            					break
                            				elseif context_line =~ '>[^<]*$' || i == curline
                            					" We are in normal tag line, no need for completion at all
                            					" OR reached first line without tag at all
                            					let b:compl_context = ''
                            					break
                            				endif
                            				let i += 1
                            			endwhile
                            			" Make sure we don't have counter
                            			unlet! i
                            		endif
   14              0.000144 		let b:compl_context = matchstr(b:compl_context, '.*\zs<.*')
                            
                            		" Return proper start for on-events. Without that beginning of
                            		" completion will be badly reported
   14              0.000096 		if b:compl_context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            		endif
                            		" If b:compl_context begins with <? we are inside of PHP code. It
                            		" wasn't closed so PHP completion passed it to HTML
   14              0.000057 		if &filetype =~? 'php' && b:compl_context =~ '^<?'
                            			let b:phpcompl = 1
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
                            				let start -= 1
                            			endwhile
                            		endif
   14              0.000013 	else
                            		let b:compl_context = getline('.')[0:compl_begin]
                            	endif
   14              0.000020     return start
                              else
                            	" Initialize base return lists
   12              0.000022     let res = []
   12              0.000017     let res2 = []
                            	" a:base is very short - we need context
   12              0.000026 	let context = b:compl_context
                            	" Check if we should do CSS completion inside of <style> tag
                            	" or JS completion inside of <script> tag or PHP completion in case of <?
                            	" tag AND &ft==php
   12              0.000029 	if exists("b:csscompl")
                            		unlet! b:csscompl
                            		let context = b:compl_context
                            		unlet! b:compl_context
                            		return csscomplete#CompleteCSS(0, context)
                            	elseif exists("b:jscompl")
                            		unlet! b:jscompl
                            		return javascriptcomplete#CompleteJS(0, a:base)
                            	elseif exists("b:phpcompl")
                            		unlet! b:phpcompl
                            		let context = b:compl_context
                            		return phpcomplete#CompletePHP(0, a:base)
                            	else
   12              0.000037 		if len(b:compl_context) == 0 && !exists("b:entitiescompl")
                            			return []
                            		endif
   12              0.000098 		let context = matchstr(b:compl_context, '.\zs.*')
   12              0.000009 	endif
   12              0.000045 	unlet! b:compl_context
                            	" Entities completion {{{
   12              0.000025 	if exists("b:entitiescompl")
                            		unlet! b:entitiescompl
                            
                            		if !exists("b:html_doctype")
                            			call htmlcomplete#CheckDoctype()
                            		endif
                            		if !exists("b:html_omni")
                            			"runtime! autoload/xml/xhtml10s.vim
                            			call htmlcomplete#LoadData()
                            		endif
                            
                            	    let entities =  b:html_omni['vimxmlentities']
                            
                            		if len(a:base) == 1
                            			for m in entities
                            				if m =~ '^'.a:base
                            					call add(res, m.';')
                            				endif
                            			endfor
                            			return res
                            		else
                            			for m in entities
                            				if m =~? '^'.a:base
                            					call add(res, m.';')
                            				elseif m =~? a:base
                            					call add(res2, m.';')
                            				endif
                            			endfor
                            
                            			return res + res2
                            		endif
                            
                            
                            	endif
                            	" }}}
   12              0.000030 	if context =~ '>'
                            		" Generally if context contains > it means we are outside of tag and
                            		" should abandon action - with one exception: <style> span { bo
                            		if context =~ 'style[^>]\{-}>[^<]\{-}$'
                            			return csscomplete#CompleteCSS(0, context)
                            		elseif context =~ 'script[^>]\{-}>[^<]\{-}$'
                            			let b:jsrange = [line('.'), search('<\/script\>', 'nW')]
                            			return javascriptcomplete#CompleteJS(0, context)
                            		else
                            			return []
                            		endif
                            	endif
                            
                            	" If context contains > it means we are already outside of tag and we
                            	" should abandon action
                            	" If context contains white space it is attribute.
                            	" It can be also value of attribute.
                            	" We have to get first word to offer proper completions
   12              0.000016 	if context == ''
    1              0.000002 		let tag = ''
    1              0.000001 	else
   11              0.000113 		let tag = split(context)[0]
                            		" Detect if tag is uppercase to return in proper case,
                            		" we need to make it lowercase for processing
   11              0.000042 		if tag =~ '^[A-Z]*$'
                            			let uppercase_tag = 1
                            			let tag = tolower(tag)
                            		else
   11              0.000019 			let uppercase_tag = 0
   11              0.000007 		endif
   11              0.000006 	endif
                            	" Get last word, it should be attr name
   12              0.000075 	let attr = matchstr(context, '.*\s\zs.*')
                            	" Possible situations where any prediction would be difficult:
                            	" 1. Events attributes
   12              0.000053 	if context =~ '\s'
                            		" Sort out style, class, and on* cases
   10              0.000124 		if context =~? "\\(on[a-z]*\\|id\\|style\\|class\\)\\s*=\\s*[\"']"
                            			" Id, class completion {{{
    1              0.000008 			if context =~? "\\(id\\|class\\)\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
    1              0.000006 				if context =~? "class\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
    1              0.000002 					let search_for = "class"
    1              0.000001 				elseif context =~? "id\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            					let search_for = "id"
                            				endif
                            				" Handle class name completion
                            				" 1. Find lines of <link stylesheet>
                            				" 1a. Check file for @import
                            				" 2. Extract filename(s?) of stylesheet,
    1              0.000003 				call cursor(1,1)
    1              0.000023 				let head = getline(search('<head\>'), search('<\/head>'))
    1              0.000004 				let headjoined = join(copy(head), ' ')
    1              0.000003 				if headjoined =~ '<style'
                            					" Remove possibly confusing CSS operators
                            					let stylehead = substitute(headjoined, '+>\*[,', ' ', 'g')
                            					if search_for == 'class'
                            						let styleheadlines = split(stylehead)
                            						let headclasslines = filter(copy(styleheadlines), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            					else
                            						let stylesheet = split(headjoined, '[{}]')
                            						" Get all lines which fit id syntax
                            						let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            						" Filter out possible color definitions
                            						call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            						" Filter out complex border definitions
                            						call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            						let templines = join(classlines, ' ')
                            						let headclasslines = split(templines)
                            						call filter(headclasslines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            					endif
                            					let internal = 1
                            				else
    1              0.000001 					let internal = 0
    1              0.000000 				endif
    1              0.000001 				let styletable = []
    1              0.000002 				let secimportfiles = []
    1              0.000004 				let filestable = filter(copy(head), "v:val =~ '\\(@import\\|link.*stylesheet\\)'")
    1              0.000002 				for line in filestable
                            					if line =~ "@import"
                            						let styletable += [matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")]
                            					elseif line =~ "<link"
                            						let styletable += [matchstr(line, "href\\s*=\\s*[\"']\\zs\\f\\+\\ze")]
                            					endif
                            				endfor
    1              0.000001 				for file in styletable
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let secimport = filter(copy(stylesheet), "v:val =~ '@import'")
                            						if len(secimport) > 0
                            							for line in secimport
                            								let secfile = matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")
                            								let secfile = fnamemodify(file, ":p:h").'/'.secfile
                            								let secimportfiles += [secfile]
                            							endfor
                            						endif
                            					endif
                            				endfor
    1              0.000002 				let cssfiles = styletable + secimportfiles
    1              0.000001 				let classes = []
    1              0.000001 				for file in cssfiles
                            				  	let classlines = []
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let stylefile = join(stylesheet, ' ')
                            						let stylefile = substitute(stylefile, '+>\*[,', ' ', 'g')
                            						if search_for == 'class'
                            							let stylesheet = split(stylefile)
                            							let classlines = filter(copy(stylesheet), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            						else
                            							let stylesheet = split(stylefile, '[{}]')
                            							" Get all lines which fit id syntax
                            							let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            							" Filter out possible color definitions
                            							call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            							" Filter out complex border definitions
                            							call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            							let templines = join(classlines, ' ')
                            							let stylelines = split(templines)
                            							let classlines = filter(stylelines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            
                            						endif
                            					endif
                            					" We gathered classes definitions from all external files
                            					let classes += classlines
                            				endfor
    1              0.000001 				if internal == 1
                            					let classes += headclasslines
                            				endif
                            
    1              0.000001 				if search_for == 'class'
    1              0.000001 					let elements = {}
    1              0.000001 					for element in classes
                            						if element =~ '^\.'
                            							let class = matchstr(element, '^\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let class = substitute(class, ':.*', '', '')
                            							if has_key(elements, 'common')
                            								let elements['common'] .= ' '.class
                            							else
                            								let elements['common'] = class
                            							endif
                            						else
                            							let class = matchstr(element, '[a-zA-Z1-6]*\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let tagname = tolower(matchstr(element, '[a-zA-Z1-6]*\ze.'))
                            							if tagname != ''
                            								if has_key(elements, tagname)
                            									let elements[tagname] .= ' '.class
                            								else
                            									let elements[tagname] = class
                            								endif
                            							endif
                            						endif
                            					endfor
                            
    1              0.000002 					if has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements[tag]." ".elements['common'])
                            					elseif has_key(elements, tag) && !has_key(elements, 'common')
                            						let values = split(elements[tag])
                            					elseif !has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements['common'])
                            					else
    1              0.000001 						return []
                            					endif
                            
                            				elseif search_for == 'id'
                            					" Find used IDs
                            					" 1. Catch whole file
                            					let filelines = getline(1, line('$'))
                            					" 2. Find lines with possible id
                            					let used_id_lines = filter(filelines, 'v:val =~ "id\\s*=\\s*[\"''][a-zA-Z0-9_-]\\+"')
                            					" 3a. Join all filtered lines
                            					let id_string = join(used_id_lines, ' ')
                            					" 3b. And split them to be sure each id is in separate item
                            					let id_list = split(id_string, 'id\s*=\s*')
                            					" 4. Extract id values
                            					let used_id = map(id_list, 'matchstr(v:val, "[\"'']\\zs[a-zA-Z0-9_-]\\+\\ze")')
                            					let joined_used_id = ','.join(used_id, ',').','
                            
                            					let allvalues = map(classes, 'matchstr(v:val, ".*#\\zs[a-zA-Z0-9_-]\\+")')
                            
                            					let values = []
                            
                            					for element in classes
                            						if joined_used_id !~ ','.element.','
                            							let values += [element]
                            						endif
                            
                            					endfor
                            
                            				endif
                            
                            				" We need special version of sbase
                            				let classbase = matchstr(context, ".*[\"']")
                            				let classquote = matchstr(classbase, '.$')
                            
                            				let entered_class = matchstr(attr, ".*=\\s*[\"']\\zs.*")
                            
                            				for m in sort(values)
                            					if m =~? '^'.entered_class
                            						call add(res, m . classquote)
                            					elseif m =~? entered_class
                            						call add(res2, m . classquote)
                            					endif
                            				endfor
                            
                            				return res + res2
                            
                            			elseif context =~? "style\\s*=\\s*[\"'][^\"']*$"
                            				return csscomplete#CompleteCSS(0, context)
                            
                            			endif
                            			" }}}
                            			" Complete on-events {{{
                            			if context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            				" We have to:
                            				" 1. Find external files
                            				let b:js_extfiles = []
                            				let l = line('.')
                            				let c = col('.')
                            				call cursor(1,1)
                            				while search('<\@<=script\>', 'W') && line('.') <= l
                            					if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            						let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            						if filereadable(sname)
                            							let b:js_extfiles += readfile(sname)
                            						endif
                            					endif
                            				endwhile
                            				" 2. Find at least one <script> tag
                            				call cursor(1,1)
                            				let js_scripttags = []
                            				while search('<script\>', 'W') && line('.') < l
                            					if matchstr(getline('.'), '<script[^>]*src') == ''
                            						let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            						let js_scripttags += js_scripttag
                            					endif
                            				endwhile
                            				let b:js_extfiles += js_scripttags
                            
                            				" 3. Proper call for javascriptcomplete#CompleteJS
                            				call cursor(l,c)
                            				let js_context = matchstr(a:base, '\k\+$')
                            				let js_shortcontext = substitute(a:base, js_context.'$', '', '')
                            				let b:compl_context = context
                            				let b:jsrange = [l, l]
                            				unlet! l c
                            				return javascriptcomplete#CompleteJS(0, js_context)
                            
                            			endif
                            
                            			" }}}
                            			let stripbase = matchstr(context, ".*\\(on[a-zA-Z]*\\|style\\|class\\)\\s*=\\s*[\"']\\zs.*")
                            			" Now we have context stripped from all chars up to style/class.
                            			" It may fail with some strange style value combinations.
                            			if stripbase !~ "[\"']"
                            				return []
                            			endif
                            		endif
                            		" Value of attribute completion {{{
                            		" If attr contains =\s*[\"'] we catched value of attribute
    9              0.000089 		if attr =~ "=\s*[\"']" || attr =~ "=\s*$"
                            			" Let do attribute specific completion
                            			let attrname = matchstr(attr, '.*\ze\s*=')
                            			let entered_value = matchstr(attr, ".*=\\s*[\"']\\?\\zs.*")
                            			let values = []
                            			" Load data {{{
                            			if !exists("b:html_doctype")
                            				call htmlcomplete#CheckDoctype()
                            			endif
                            			if !exists("b:html_omni")
                            				"runtime! autoload/xml/xhtml10s.vim
                            				call htmlcomplete#LoadData()
                            			endif
                            			" }}}
                            			if attrname == 'href'
                            				" Now we are looking for local anchors defined by name or id
                            				if entered_value =~ '^#'
                            					let file = join(getline(1, line('$')), ' ')
                            					" Split it be sure there will be one id/name element in
                            					" item, it will be also first word [a-zA-Z0-9_-] in element
                            					let oneelement = split(file, "\\(meta \\)\\@<!\\(name\\|id\\)\\s*=\\s*[\"']")
                            					for i in oneelement
                            						let values += ['#'.matchstr(i, "^[a-zA-Z][a-zA-Z0-9%_-]*")]
                            					endfor
                            				endif
                            			else
                            				if has_key(b:html_omni, tag) && has_key(b:html_omni[tag][1], attrname)
                            					let values = b:html_omni[tag][1][attrname]
                            				else
                            					return []
                            				endif
                            			endif
                            
                            			if len(values) == 0
                            				return []
                            			endif
                            
                            			" We need special version of sbase
                            			let attrbase = matchstr(context, ".*[\"']")
                            			let attrquote = matchstr(attrbase, '.$')
                            			if attrquote !~ "['\"]"
                            				let attrquoteopen = '"'
                            				let attrquote = '"'
                            			else
                            				let attrquoteopen = ''
                            			endif
                            
                            			for m in values
                            				" This if is needed to not offer all completions as-is
                            				" alphabetically but sort them. Those beginning with entered
                            				" part will be as first choices
                            				if m =~ '^'.entered_value
                            					call add(res, attrquoteopen . m . attrquote)
                            				elseif m =~ entered_value
                            					call add(res2, attrquoteopen . m . attrquote)
                            				endif
                            			endfor
                            
                            			return res + res2
                            
                            		endif
                            		" }}}
                            		" Attribute completion {{{
                            		" Shorten context to not include last word
    9              0.000077 		let sbase = matchstr(context, '.*\ze\s.*')
                            
                            		" Load data {{{
    9              0.000024 		if !exists("b:html_doctype")
    9   0.009090   0.000067 			call htmlcomplete#CheckDoctype()
    9              0.000007 		endif
    9              0.000027 		if !exists("b:html_omni")
                            			call htmlcomplete#LoadData()
                            		endif
                            		" }}}
                            
    9              0.000031 		if has_key(b:html_omni, tag)
    9              0.000078 			let attrs = keys(b:html_omni[tag][1])
    9              0.000007 		else
                            			return []
                            		endif
                            
  162              0.000229 		for m in sort(attrs)
  153              0.000412 			if m =~ '^'.attr
   41              0.000080 				call add(res, m)
   41              0.000035 			elseif m =~ attr
    8              0.000020 				call add(res2, m)
    8              0.000006 			endif
  153              0.000130 		endfor
    9              0.000036 		let menu = res + res2
    9              0.000029 		if has_key(b:html_omni, 'vimxmlattrinfo')
    9              0.000022 			let final_menu = []
   58              0.000080 			for i in range(len(menu))
   49              0.000093 				let item = menu[i]
   49              0.000150 				if has_key(b:html_omni['vimxmlattrinfo'], item)
   49              0.000163 					let m_menu = b:html_omni['vimxmlattrinfo'][item][0]
   49              0.000151 					let m_info = b:html_omni['vimxmlattrinfo'][item][1]
   49              0.000030 				else
                            					let m_menu = ''
                            					let m_info = ''
                            				endif
   49              0.000267 				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            					let m_menu = 'Bool'
                            				else
   49              0.000082 					let item .= '="'
   49              0.000031 				endif
   49              0.000249 				let final_menu += [{'word':item, 'menu':m_menu, 'info':m_info}]
   49              0.000036 			endfor
    9              0.000007 		else
                            			let final_menu = []
                            			for i in range(len(menu))
                            				let item = menu[i]
                            				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            				else
                            					let item .= '="'
                            				endif
                            				let final_menu += [item]
                            			endfor
                            			return final_menu
                            
                            		endif
    9              0.000015 		return final_menu
                            
                            	endif
                            	" }}}
                            	" Close tag {{{
    2              0.000009 	let b:unaryTagsStack = "base meta link hr br param img area input col"
    2              0.000006 	if context =~ '^\/'
                            		if context =~ '^\/.'
                            			return []
                            		else
                            			let opentag = xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
                            			return [opentag.">"]
                            		endif
                            	endif
                            	" }}}
                            	" Load data {{{
    2              0.000004 	if !exists("b:html_doctype")
    2   0.001776   0.000020 		call htmlcomplete#CheckDoctype()
    2              0.000001 	endif
    2              0.000005 	if !exists("b:html_omni")
                            		"runtime! autoload/xml/xhtml10s.vim
                            		call htmlcomplete#LoadData()
                            	endif
                            	" }}}
                            	" Tag completion {{{
                            	" Deal with tag completion.
    2   0.001494   0.000024 	let opentag = tolower(xmlcomplete#GetLastOpenTag("b:unaryTagsStack"))
                            	" MM: TODO: GLOT works always the same but with some weird situation it
                            	" behaves as intended in HTML but screws in PHP
    2              0.000008 	if opentag == '' || &filetype == 'php' && !has_key(b:html_omni, opentag)
                            		" Hack for sometimes failing GetLastOpenTag.
                            		" As far as I tested fail isn't GLOT fault but problem
                            		" of invalid document - not properly closed tags and other mish-mash.
                            		" Also when document is empty. Return list of *all* tags.
                            	    let tags = keys(b:html_omni)
                            		call filter(tags, 'v:val !~ "^vimxml"')
                            	else
    2              0.000006 		if has_key(b:html_omni, opentag)
    1              0.000006 			let tags = b:html_omni[opentag][0]
    1              0.000001 		else
    1              0.000001 			return []
                            		endif
    1              0.000001 	endif
                            	" }}}
                            
    1              0.000004 	if exists("uppercase_tag") && uppercase_tag == 1
                            		let context = tolower(context)
                            	endif
                            	" Handle XML keywords: DOCTYPE
    1              0.000001 	if opentag == ''
                            		let tags += [ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">', '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">', '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">' ]
                            	endif
                            
   63              0.000079 	for m in sort(tags)
   62              0.000163 		if m =~ '^'.context
   62              0.000126 			call add(res, m)
   62              0.000065 		elseif m =~ context
                            			call add(res2, m)
                            		endif
   62              0.000046 	endfor
    1              0.000015 	let menu = res + res2
    1              0.000004 	if has_key(b:html_omni, 'vimxmltaginfo')
    1              0.000002 		let final_menu = []
   63              0.000072 		for i in range(len(menu))
   62              0.000128 			let item = menu[i]
   62              0.000199 			if has_key(b:html_omni['vimxmltaginfo'], item)
    6              0.000023 				let m_menu = b:html_omni['vimxmltaginfo'][item][0]
    6              0.000020 				let m_info = b:html_omni['vimxmltaginfo'][item][1]
    6              0.000004 			else
   56              0.000074 				let m_menu = ''
   56              0.000072 				let m_info = ''
   56              0.000036 			endif
   62              0.000194 			if &filetype == 'html' && exists("uppercase_tag") && uppercase_tag == 1 && item !~ 'DOCTYPE'
                            				let item = toupper(item)
                            			endif
   62              0.000180 			if item =~ 'DOCTYPE'
                            				let abbr = 'DOCTYPE '.matchstr(item, 'DTD \zsX\?HTML .\{-}\ze\/\/')
                            			else
   62              0.000093 				let abbr = item
   62              0.000039 			endif
   62              0.000394 			let final_menu += [{'abbr':abbr, 'word':item, 'menu':m_menu, 'info':m_info}]
   62              0.000049 		endfor
    1              0.000001 	else
                            		let final_menu = menu
                            	endif
    1              0.000002 	return final_menu
                            
                            	" }}}
                              endif

FUNCTION  <SNR>178_NeoVimCallback()
Called 22 times
Total time:   0.012025
 Self time:   0.001733

count  total (s)   self (s)
   22              0.000185     let l:info = s:job_map[a:job]
                            
   22              0.000061     if a:event is# 'stdout'
    8   0.001045   0.000145         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
    8              0.000013     elseif a:event is# 'stderr'
    7   0.000616   0.000208         let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
    7              0.000006     else
    7              0.000032         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
                                    endif
                            
    7              0.000023         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
                                    endif
                            
    7              0.000011         try
    7   0.009075   0.000092             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
    7              0.000009         finally
                                        " Automatically forget about the job after it's done.
    7              0.000019             if has_key(s:job_map, a:job)
    7              0.000026                 call remove(s:job_map, a:job)
    7              0.000006             endif
    7              0.000007         endtry
    7              0.000005     endif

FUNCTION  ale#sign#ParseSigns()
Called 1 time
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
                                " Matches output like :
                                " line=4  id=1  name=ALEErrorSign
                                " строка=1  id=1000001  имя=ALEErrorSign
                                " 行=1  識別子=1000001  名前=ALEWarningSign
                                " línea=12 id=1000001 nombre=ALEWarningSign
                                " riga=1 id=1000001, nome=ALEWarningSign
    1              0.000002     let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
    1              0.000001     let l:result = []
    1              0.000001     let l:is_dummy_sign_set = 0
                            
   13              0.000010     for l:line in a:line_list
   12              0.000133         let l:match = matchlist(l:line, l:pattern)
                            
   12              0.000015         if len(l:match) > 0
    1              0.000002             if l:match[3] is# 'ALEDummySign'
    1              0.000001                 let l:is_dummy_sign_set = 1
    1              0.000000             else
                                            call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
                                        endif
    1              0.000000         endif
   12              0.000006     endfor
                            
    1              0.000002     return [l:is_dummy_sign_set, l:result]

FUNCTION  <SNR>112_exec_separator()
Called 225 times
Total time:   0.138778
 Self time:   0.006777

count  total (s)   self (s)
  225              0.000297   if pumvisible()
                                return
                              endif
  225              0.000592   let group = a:from.'_to_'.a:to.a:suffix
  225   0.042418   0.000979   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  225   0.039977   0.001035   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  225              0.000212   if a:inverse
   43              0.000163     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   43              0.000025   else
  182              0.000614     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  182              0.000084   endif
  225              0.000615   let a:dict[group] = colors
  225   0.052685   0.001065   call airline#highlighter#exec(group, colors)

FUNCTION  ale#history#SetExitCode()
Called 1 time
Total time:   0.000031
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000026   0.000007     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    1              0.000002     let l:obj.exit_code = a:exit_code
    1              0.000001     let l:obj.status = 'finished'

FUNCTION  ale#util#Writefile()
Called 7 times
Total time:   0.000379
 Self time:   0.000379

count  total (s)   self (s)
    7              0.000056     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
    7              0.000311     call writefile(l:corrected_lines, a:filename) " no-custom-checks

FUNCTION  tagbar#is_paused()
Called 5 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    5              0.000006     return s:paused

FUNCTION  gitgutter#diff#parse_diff()
Called 1 time
Total time:   0.000181
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000001   let hunks = []
    4              0.000010   for line in split(a:diff, '\n')
    3   0.000137   0.000024     let hunk_info = gitgutter#diff#parse_hunk(line)
    3              0.000007     if len(hunk_info) == 4
    3              0.000009       call add(hunks, hunk_info)
    3              0.000002     endif
    3              0.000002   endfor
    1              0.000002   return hunks

FUNCTION  <SNR>131_CreateTemporaryFileForJob()
Called 7 times
Total time:   0.001233
 Self time:   0.000679

count  total (s)   self (s)
    7              0.000014     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
    7              0.000029     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    7              0.000409     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    7   0.000230   0.000055     call ale#engine#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    7              0.000062     let l:lines = getbufline(a:buffer, 1, '$')
    7   0.000428   0.000049     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    7              0.000013     return 1

FUNCTION  htmlcomplete#CheckDoctype()
Called 11 times
Total time:   0.010779
 Self time:   0.010779

count  total (s)   self (s)
   11              0.000032 	if exists('b:html_omni_flavor')
   11              0.000026 		let old_flavor = b:html_omni_flavor
   11              0.000008 	else
                            		let old_flavor = ''
                            	endif
   11              0.000017 	let i = 1
  110              0.000258 	while i < 10 && i < line("$")
   99              0.000249 		let line = getline(i)
   99              0.000502 		if line =~ '<!DOCTYPE.*\<DTD HTML 3\.2'
                            			let b:html_omni_flavor = 'html32'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Transitional'
                            			let b:html_omni_flavor = 'html40t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Frameset'
                            			let b:html_omni_flavor = 'html40f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0'
                            			let b:html_omni_flavor = 'html40s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Transitional'
                            			let b:html_omni_flavor = 'html401t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Frameset'
                            			let b:html_omni_flavor = 'html401f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01'
                            			let b:html_omni_flavor = 'html401s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Transitional'
                            			let b:html_omni_flavor = 'xhtml10t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Frameset'
                            			let b:html_omni_flavor = 'xhtml10f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Strict'
                            			let b:html_omni_flavor = 'xhtml10s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.1'
                            			let b:html_omni_flavor = 'xhtml11'
                            			let b:html_doctype = 1
                            			break
                            		endif
   99              0.000155 		let i += 1
   99              0.000082 	endwhile
   11              0.000035 	if !exists("b:html_doctype")
   11              0.000013 		return
                            	else
                            		" Tie g:xmldata with b:html_omni this way we need to sourca data file only
                            		" once, not every time per buffer.
                            		if old_flavor == b:html_omni_flavor
                            			return
                            		else
                            			if exists('g:xmldata_'.b:html_omni_flavor)
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			else
                            				exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			endif
                            			return
                            		endif
                            	endif

FUNCTION  ale#statusline#Count()
Called 112 times
Total time:   0.002349
 Self time:   0.000688

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
  112   0.002267   0.000606     return copy(s:GetCounts(a:buffer))

FUNCTION  <SNR>111_wrap_accent()
Called 1 time
Total time:   0.000053
 Self time:   0.000042

count  total (s)   self (s)
    1              0.000007   if exists('a:part.accent')
    1   0.000035   0.000024     call airline#highlighter#add_accent(a:part.accent)
    1              0.000009     return '%#__accent_'.(a:part.accent).'#'.a:value.'%#__restore__#'
                              endif
                              return a:value

FUNCTION  ale#engine#IsCheckingBuffer()
Called 435 times
Total time:   0.004152
 Self time:   0.004152

count  total (s)   self (s)
  435              0.001672     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
  435              0.002030     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#extensions#ale#get()
Called 426 times
Total time:   0.022082
 Self time:   0.014723

count  total (s)   self (s)
  426              0.001319   if !exists(':ALELint')
                                return ''
                              endif
                            
  426              0.001435   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
  426              0.001267   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
  426              0.001240   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
  426              0.001266   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
  426              0.000843   let is_err = a:type ==# 'error'
                            
  426   0.005975   0.001933   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
  314              0.000571     return is_err ? '' : checking_symbol
                              endif
                            
  112              0.000238   let symbol = is_err ? error_symbol : warning_symbol
                            
  112   0.002778   0.000429   let counts = ale#statusline#Count(bufnr(''))
  112              0.000356   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
  112              0.000224     let errors = counts.error + counts.style_error
  112              0.000229     let num = is_err ? errors : counts.total - errors
  112              0.000066   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
  112              0.000126   if show_line_numbers == 1
  112   0.001828   0.000860     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  tagbar#state#get_current_file()
Called 5 times
Total time:   0.000121
 Self time:   0.000039

count  total (s)   self (s)
    5   0.000119   0.000037     return s:get().getCurrent(a:force_current)

FUNCTION  FugitiveGitDir()
Called 213 times
Total time:   0.000985
 Self time:   0.000985

count  total (s)   self (s)
  213              0.000333   if !a:0 || a:1 ==# -1
  213              0.000492     return get(b:, 'git_dir', '')
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
                                return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  ale#engine#ProcessChain()
Called 7 times
Total time:   0.003462
 Self time:   0.000536

count  total (s)   self (s)
    7              0.000035     let l:output_stream = get(a:linter, 'output_stream', 'stdout')
    7              0.000016     let l:read_buffer = a:linter.read_buffer
    7              0.000013     let l:chain_index = a:chain_index
    7              0.000011     let l:input = a:input
                            
    7              0.000016     if has_key(a:linter, 'command_chain')
                                    while l:chain_index < len(a:linter.command_chain)
                                        " Run a chain of commands, one asynchronous command after the other,
                                        " so that many programs can be run in a sequence.
                                        let l:chain_item = a:linter.command_chain[l:chain_index]
                            
                                        if l:chain_index == 0
                                            " The first callback in the chain takes only a buffer number.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer)
                                        else
                                            " The second callback in the chain takes some input too.
                                            let l:command = ale#util#GetFunction(l:chain_item.callback)(   a:buffer,   l:input)
                                        endif
                            
                                        " If we have a command to run, execute that.
                                        if !empty(l:command)
                                            " The chain item can override the output_stream option.
                                            if has_key(l:chain_item, 'output_stream')
                                                let l:output_stream = l:chain_item.output_stream
                                            endif
                            
                                            " The chain item can override the read_buffer option.
                                            if has_key(l:chain_item, 'read_buffer')
                                                let l:read_buffer = l:chain_item.read_buffer
                                            elseif l:chain_index != len(a:linter.command_chain) - 1
                                                " Don't read the buffer for commands besides the last one
                                                " in the chain by default.
                                                let l:read_buffer = 0
                                            endif
                            
                                            break
                                        endif
                            
                                        " Command chain items can return an empty string to indicate that
                                        " a command should be skipped, so we should try the next item
                                        " with no input.
                                        let l:input = []
                                        let l:chain_index += 1
                                    endwhile
                                else
    7   0.002971   0.000045         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
    7              0.000005     endif
                            
    7              0.000057     return {   'command': l:command,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': l:output_stream,   'next_chain_index': l:chain_index + 1,   'read_buffer': l:read_buffer,}

FUNCTION  ale#job#ValidateArguments()
Called 7 times
Total time:   0.000062
 Self time:   0.000062

count  total (s)   self (s)
    7              0.000019     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  deoplete#util#get_keyword_pattern()
Called 33 times
Total time:   0.014222
 Self time:   0.001544

count  total (s)   self (s)
   33              0.000117   if empty(a:keyword_patterns)
   33   0.002671   0.000275     let patterns = deoplete#custom#_get_filetype_option(   'keyword_patterns', a:filetype, '')
   33              0.000030   else
                                let filetype = has_key(a:keyword_patterns, a:filetype) ? a:filetype : '_'
                                let patterns = get(a:keyword_patterns, filetype, '')
                              endif
   33   0.000420   0.000254   let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
   33   0.010431   0.000314   let k_pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
   33              0.000236   return substitute(pattern, '\\k', '\=k_pattern', 'g')

FUNCTION  <SNR>125_completion_async()
Called 22 times
Total time:   0.081190
 Self time:   0.001252

count  total (s)   self (s)
   22   0.000857   0.000580   if mode() !=# 'i' || s:is_exiting()
                                call deoplete#handler#_async_timer_stop()
                                return
                              endif
                            
   22   0.080070   0.000410   call s:completion_begin(s:async_timer.event)

FUNCTION  gitgutter#utility#extension()
Called 1 time
Total time:   0.000032
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000032   0.000005   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>176_FindHistoryItem()
Called 2 times
Total time:   0.000033
 Self time:   0.000022

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
    2   0.000024   0.000012     for l:obj in reverse(ale#history#Get(a:buffer))
    2              0.000003         if l:obj.job_id == a:job_id
    2              0.000002             return l:obj
                                    endif
                                endfor
                            
                                return {}

FUNCTION  airline#builder#get_prev_group()
Called 4 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    4              0.000013   let x = a:i - 1
    4              0.000009   while x >= 0
    3              0.000013     let group = a:sections[x][0]
    3              0.000012     if group != '' && group != '|'
    3              0.000006       return group
                                endif
                                let x = x - 1
                              endwhile
    1              0.000002   return ''

FUNCTION  <SNR>90_AddEval()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000004   if has_key(a:opts, 'eval')
                                if type(a:opts.eval) != type('') || a:opts.eval == ''
                                  throw "Eval option must be a non-empty string"
                                endif
                                " evaluate an expression and pass as argument
                                call add(a:rpcargs, 'eval("'.escape(a:opts.eval, '"').'")')
                              endif

FUNCTION  airline#extensions#apply_left_override()
Called 1 time
Total time:   0.000498
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000007   let w:airline_section_a = a:section1
    1              0.000005   let w:airline_section_b = a:section2
    1   0.000474   0.000043   let w:airline_section_c = airline#section#create(['readonly'])
    1              0.000005   let w:airline_render_left = 1
    1              0.000004   let w:airline_render_right = 0

FUNCTION  gitgutter#hunk#hunks()
Called 1 time
Total time:   0.000012
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000011   0.000004   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  gitgutter#hunk#increment_lines_modified()
Called 2 times
Total time:   0.000061
 Self time:   0.000018

count  total (s)   self (s)
    2   0.000029   0.000007   let summary = gitgutter#hunk#summary(a:bufnr)
    2              0.000003   let summary[1] += a:count
    2   0.000028   0.000007   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ale#Queue()
Called 8 times
Total time:   0.001193
 Self time:   0.000407

count  total (s)   self (s)
    8              0.000012     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
    8              0.000031     let l:buffer = get(a:000, 1, v:null)
                            
    8              0.000014     if l:buffer is v:null
    8              0.000020         let l:buffer = bufnr('')
    8              0.000005     endif
                            
    8              0.000020     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
    8   0.000832   0.000047     if ale#ShouldDoNothing(l:buffer)
    1              0.000000         return
                                endif
                            
                                " Default linting_flag to ''
    7              0.000024     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    7              0.000010     if s:lint_timer != -1
    6              0.000016         call timer_stop(s:lint_timer)
    6              0.000011         let s:lint_timer = -1
    6              0.000004     endif
                            
    7              0.000008     if a:delay > 0
    7              0.000064         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    7              0.000005     else
                                    call s:Lint(l:buffer, l:should_lint_file, 0)
                                endif

FUNCTION  <SNR>164_GetAliasedFiletype()
Called 28 times
Total time:   0.000360
 Self time:   0.000360

count  total (s)   self (s)
   28              0.000135     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
   28              0.000124     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
   28              0.000046         return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
                                for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
                                    if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
                                endfor
                            
                                return a:original_filetype

FUNCTION  <SNR>49_NERDTreeTrimDoubleQuotes()
Called 102 times
Total time:   0.001811
 Self time:   0.001811

count  total (s)   self (s)
  102              0.000765     let l:toReturn = substitute(a:pathStr, '^"', '', '')
  102              0.000677     let l:toReturn = substitute(l:toReturn, '"$', '', '')
  102              0.000222     return l:toReturn

FUNCTION  <SNR>116_get_section()
Called 4 times
Total time:   0.000319
 Self time:   0.000289

count  total (s)   self (s)
    4              0.000025   if has_key(s:section_truncate_width, a:key)
    1              0.000007     if winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
                                endif
    1              0.000001   endif
    4              0.000018   let spc = g:airline_symbols.space
    4              0.000035   if !exists('g:airline_section_{a:key}')
                                return ''
                              endif
    4   0.000095   0.000065   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
    4              0.000054   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
    4              0.000030   return empty(text) ? '' : prefix.text.suffix

FUNCTION  ale#engine#IsExecutable()
Called 7 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    7              0.000015     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
    7              0.000036     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
    7              0.000012     if l:result isnot v:null
    7              0.000008         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result

FUNCTION  ale#Escape()
Called 21 times
Total time:   0.000321
 Self time:   0.000321

count  total (s)   self (s)
   21              0.000081     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
   21              0.000079     return shellescape (a:str)

FUNCTION  <SNR>117_Lint()
Called 7 times
Total time:   0.042026
 Self time:   0.000854

count  total (s)   self (s)
                                " Use the filetype from the buffer
    7              0.000128     let l:filetype = getbufvar(a:buffer, '&filetype')
    7   0.010142   0.000120     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
    7   0.000140   0.000043     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    7              0.000039     let l:linters = !empty(l:ignore_config)   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
    7              0.000021     let g:ale_want_results_buffer = a:buffer
    7   0.000305   0.000217     silent doautocmd <nomodeline> User ALEWantResults
    7              0.000022     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    7              0.000040     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    7              0.000047     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    7   0.031037   0.000072     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  airline#update_statusline_inactive()
Called 1 time
Total time:   0.000054
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000016   0.000010   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    1              0.000005   for nr in a:range
                                if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
                              endfor

FUNCTION  <SNR>127_HandleOnlyWindow()
Called 1 time
Total time:   0.000086
 Self time:   0.000078

count  total (s)   self (s)
    1   0.000082   0.000074     let tagbarwinnr = bufwinnr(s:TagbarBufName())
    1              0.000002     if tagbarwinnr == -1
    1              0.000001         return
                                endif
                            
                                let vim_quitting = s:vim_quitting
                                let s:vim_quitting = 0
                            
                                if vim_quitting && !s:HasOpenFileWindows()
                                    call tagbar#debug#log('Closing Tagbar window due to QuitPre event')
                                    if winnr('$') >= 1
                                        call s:goto_win(tagbarwinnr, 1)
                                    endif
                            
                                    " Before quitting Vim, delete the tagbar buffer so that the '0 mark is
                                    " correctly set to the previous buffer.
                                    if tabpagenr('$') == 1
                                        noautocmd keepalt bdelete
                                    endif
                            
                                    try
                                        try
                                            quit
                                        catch /.*/ " This can be E173 and maybe others
                                            call s:OpenWindow('')
                                            echoerr v:exception
                                        endtry
                                    catch /.*/
                                        echohl ErrorMsg
                                        echo v:exception
                                        echohl None
                                    endtry
                                endif

FUNCTION  <SNR>161_is_removed()
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003   return a:from_count > 0 && a:to_count == 0

FUNCTION  ale#node#FindExecutable()
Called 21 times
Total time:   0.005880
 Self time:   0.000795

count  total (s)   self (s)
   21   0.000411   0.000135     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
                                endif
                            
   42              0.000080     for l:path in a:path_list
   35   0.004941   0.000216         let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
                            
   35              0.000071         if !empty(l:executable)
   14              0.000019             return l:executable
                                    endif
   21              0.000017     endfor
                            
    7   0.000126   0.000042     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  deoplete#util#convert2list()
Called 165 times
Total time:   0.000831
 Self time:   0.000831

count  total (s)   self (s)
  165              0.000740   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  <SNR>161_save_last_seen_change()
Called 1 time
Total time:   0.000017
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000017   0.000005   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  gitgutter#async#available()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000001   return s:available

FUNCTION  <SNR>104_update_untracked()
Called 213 times
Total time:   0.017989
 Self time:   0.015196

count  total (s)   self (s)
  213              0.003051   let file = expand("%:p")
  213              0.001035   if empty(file) || isdirectory(file)
                                return
                              endif
                            
  213              0.000353   let needs_update = 1
  639              0.001024   for vcs in keys(s:vcs_config)
  426              0.001714     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
  426              0.001281     if has_key(s:vcs_config[vcs].untracked, file)
  213              0.000290       let needs_update = 0
  213   0.004057   0.001264       call airline#extensions#branch#update_untracked_config(file, vcs)
  213              0.000121     endif
  426              0.000292   endfor
                            
  213              0.000231   if !needs_update
  213              0.000163     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                let config = s:vcs_config[vcs]
                                if g:airline#init#vim_async
                                  " Note that asynchronous update updates s:vcs_config only, and only
                                  " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                  " invalidated again before s:update_untracked is called, then we lose the
                                  " result of the previous call, i.e. the head string is not updated. It
                                  " doesn't happen often in practice, so we let it be.
                                  noa call airline#async#vim_vcs_untracked(config, file)
                                else
                                  " nvim async or vim without job-feature
                                  noa call airline#async#nvim_vcs_untracked(config, file, vcs)
                                endif
                              endfor

FUNCTION  deoplete#util#get_context_filetype()
Called 37 times
Total time:   0.004651
 Self time:   0.003809

count  total (s)   self (s)
   37              0.000148   if !exists('s:context_filetype')
                                let s:context_filetype = {}
                            
                                " Force context_filetype call.
                                try
                                  call context_filetype#get_filetype()
                                catch
                                  " Ignore error
                                endtry
                              endif
                            
   37              0.001565   if empty(s:context_filetype) || s:context_filetype.prev_filetype !=# &filetype || s:context_filetype.line != line('.') || s:context_filetype.bufnr != bufnr('%') || (a:input =~# '\W$' &&     substitute(a:input, '\s\zs\s\+$', '', '') !=#     substitute(s:context_filetype.input, '\s\zs\s\+$', '', '')) || (a:input =~# '\w$' &&     substitute(a:input, '\w\+$', '', '') !=#     substitute(s:context_filetype.input, '\w\+$', '', '')) || a:event ==# 'InsertEnter'
                            
    6              0.000038     let s:context_filetype.line = line('.')
    6              0.000022     let s:context_filetype.bufnr = bufnr('%')
    6              0.000023     let s:context_filetype.input = a:input
    6              0.000018     let s:context_filetype.prev_filetype = &filetype
    6              0.000056     let s:context_filetype.filetype = (exists('*context_filetype#get_filetype') ?   context_filetype#get_filetype() :   (&filetype ==# '' ? 'nothing' : &filetype))
    6   0.000998   0.000155     let s:context_filetype.filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes() :   &filetype ==# '' ? ['nothing'] :                     deoplete#util#uniq([&filetype]                          + split(&filetype, '\.'))
    6              0.000051     let s:context_filetype.same_filetypes = exists('*context_filetype#get_same_filetypes') ?   context_filetype#get_same_filetypes() : []
    6              0.000005   endif
   37              0.000204   return [ s:context_filetype.filetype,  s:context_filetype.filetypes, s:context_filetype.same_filetypes]

FUNCTION  ale_linters#vue#vls#GetProjectRoot()
Called 7 times
Total time:   0.000880
 Self time:   0.000130

count  total (s)   self (s)
    7   0.000828   0.000078     let l:package_path = ale#path#FindNearestFile(a:buffer, 'package.json')
                            
    7              0.000042     return !empty(l:package_path) ? fnamemodify(l:package_path, ':h') : ''

FUNCTION  airline#parts#get()
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000008   return get(s:parts, a:key, {})

FUNCTION  <SNR>112_get_array()
Called 1658 times
Total time:   0.013749
 Self time:   0.013749

count  total (s)   self (s)
 1658              0.005817   let opts=empty(a:opts) ? '' : join(a:opts, ',')
 1658              0.006926   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#parts#paste()
Called 213 times
Total time:   0.000652
 Self time:   0.000652

count  total (s)   self (s)
  213              0.000573   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
Called 1 time
Total time:   0.010344
 Self time:   0.000154

count  total (s)   self (s)
    1   0.000029   0.000020   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
                              endif
    1              0.000015   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    1   0.000073   0.000019   call airline#update_statusline_inactive(range)
                            
    1              0.000009   unlet! w:airline_render_left w:airline_render_right
    1              0.000035   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
    1              0.000006   let w:airline_active = 1
    1              0.000011   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    1   0.010152   0.000025   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>127_ShrinkIfExpanded()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002     if !s:window_expanded || &filetype == 'tagbar' || s:expand_bufnr == -1
    1              0.000001         return
                                endif
                            
                                let tablist = []
                                for i in range(tabpagenr('$'))
                                    call extend(tablist, tabpagebuflist(i + 1))
                                endfor
                            
                                if index(tablist, s:expand_bufnr) == -1
                                    let &columns -= g:tagbar_width + 1
                                    let s:window_expanded = 0
                                    let s:expand_bufnr = -1
                                    " Only restore window position if it is available and if the
                                    " window hasn't been moved manually after the expanding
                                    if getwinposx() != -1 && getwinposx() == s:window_pos.post.x && getwinposy() == s:window_pos.post.y
                                       execute 'winpos ' . s:window_pos.pre.x . ' ' . s:window_pos.pre.y
                                    endif
                                endif
                            
                                " The window sizes may have changed due to the shrinking happening after
                                " the window closing, so equalize them again.
                                if &equalalways
                                    wincmd =
                                endif

FUNCTION  <SNR>125_check_omnifunc()
Called 36 times
Total time:   0.014236
 Self time:   0.006640

count  total (s)   self (s)
   36              0.000130   let prev = g:deoplete#_prev_completion
   36              0.000116   let blacklist = ['LanguageClient#complete']
   36              0.000303   if a:context.event ==# 'Manual' || &l:omnifunc ==# '' || index(blacklist, &l:omnifunc) >= 0 || prev.input ==# a:context.input
   13              0.000020     return
                              endif
                            
  108              0.000234   for filetype in a:context.filetypes
  224   0.008600   0.001242     for pattern in deoplete#util#convert2list( deoplete#custom#_get_filetype_option(   'omni_patterns', filetype, ''))
  139              0.000869       if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
   10              0.000034         let g:deoplete#_context.candidates = []
                            
   10              0.000024         let prev.event = a:context.event
   10              0.000020         let prev.input = a:context.input
   10              0.000015         let prev.candidates = []
                            
   10   0.000294   0.000055         call deoplete#mapping#_set_completeopt()
   10              0.000067         call feedkeys("\<C-x>\<C-o>", 'in')
   10              0.000011         return 1
                                  endif
  129              0.000131     endfor
   85              0.000074   endfor

FUNCTION  deoplete#custom#_get_option()
Called 621 times
Total time:   0.023676
 Self time:   0.013744

count  total (s)   self (s)
  621   0.021649   0.011716   let custom = extend(copy(deoplete#custom#_get().option), deoplete#custom#_get_buffer().option)
  621              0.001540   return custom[a:name]

FUNCTION  deoplete#send_event()
Called 1 time
Total time:   0.004703
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000008   let sources = get(a:000, 0, [])
    1   0.004693   0.000058   call deoplete#util#rpcnotify('deoplete_on_event', deoplete#init#_context(a:event, sources))

FUNCTION  ale#engine#RunLinters()
Called 7 times
Total time:   0.030965
 Self time:   0.000845

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    7   0.000159   0.000042     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
    7   0.001101   0.000068     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
    7   0.000288   0.000071     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    7   0.000140   0.000046     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    7   0.000201   0.000116     silent doautocmd <nomodeline> User ALELintPre
                            
   21              0.000042     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   14              0.000033         if !l:linter.lint_file || a:should_lint_file
   14   0.028671   0.000095             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
    7              0.000023                 let l:can_clear_results = 0
    7              0.000005             endif
   14              0.000012         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
   14              0.000014     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    7              0.000009     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
                                    call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
                                endif

FUNCTION  gitgutter#utility#setbufvar()
Called 13 times
Total time:   0.000176
 Self time:   0.000176

count  total (s)   self (s)
   13              0.000018   let buffer = +a:buffer
   13              0.000039   let dict = get(getbufvar(buffer, '', {}), 'gitgutter', {})
   13              0.000024   let needs_setting = empty(dict)
   13              0.000048   let dict[a:varname] = a:val
   13              0.000011   if needs_setting
                                call setbufvar(buffer, 'gitgutter', dict)
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 213 times
Total time:   0.023597
 Self time:   0.020746

count  total (s)   self (s)
  213              0.000679   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  213              0.001090   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
  213              0.001564   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  213              0.000561   if !exists('b:airline_whitespace_check')
    1              0.000003     let b:airline_whitespace_check = ''
    1              0.000005     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    1              0.000001     let trailing = 0
    1              0.000001     let check = 'trailing'
    1              0.000007     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1              0.000001       try
    1              0.000002         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    1              0.000013         let trailing = search(regexp, 'nw')
    1              0.000001       catch
                                    echomsg 'airline#whitespace: error occurred evaluating '. regexp
                                    echomsg v:exception
                                    return ''
                                  endtry
    1              0.000001     endif
                            
    1              0.000001     let mixed = 0
    1              0.000001     let check = 'indent'
    1              0.000006     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000077   0.000008       let mixed = s:check_mixed_indent()
    1              0.000001     endif
                            
    1              0.000001     let mixed_file = ''
    1              0.000001     let check = 'mixed-indent-file'
    1              0.000007     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    1   0.000035   0.000008       let mixed_file = s:check_mixed_indent_file()
    1              0.000000     endif
                            
    1              0.000001     let long = 0
    1              0.000002     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
    1              0.000002     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file)
    1              0.000002       let b:airline_whitespace_check = s:symbol
    1              0.000001       if strlen(s:symbol) > 0
    1              0.000002         let space = (g:airline_symbols.space)
    1              0.000001       else
                                    let space = ''
                                  endif
                            
    1              0.000001       if s:show_message
    1              0.000001         if trailing != 0
    1              0.000003           let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
    1              0.000005           let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
    1              0.000001         endif
    1              0.000001         if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
    1              0.000001         if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
    1              0.000001         if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
    1              0.000001       endif
    1              0.000000     endif
    1              0.000001   endif
  213   0.003775   0.001019   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>107_check_mixed_indent()
Called 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000003   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    1              0.000001   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw')
                              else
    1              0.000057     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  <SNR>116_build_sections()
Called 1 time
Total time:   0.000558
 Self time:   0.000101

count  total (s)   self (s)
    4              0.000011   for key in a:keys
    3              0.000017     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
                                endif
    3   0.000496   0.000039     call s:add_section(a:builder, a:context, key)
    3              0.000005   endfor

FUNCTION  <SNR>184_SetListsImpl()
Called 1 time
Total time:   0.000998
 Self time:   0.000126

count  total (s)   self (s)
    1              0.000013     let l:title = expand('#' . a:buffer . ':p')
                            
    1              0.000001     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, bufwinid() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    1   0.000011   0.000006         let l:id = s:BufWinId(a:buffer)
                            
    1              0.000002         if has('nvim')
    1   0.000847   0.000033             call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
    1              0.000001         else
                                        call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                        call setloclist(l:id, [], 'r', {'title': l:title})
                                    endif
    1              0.000000     endif
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    1   0.000023   0.000006     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                                    let l:reset_visual_selection = l:mode is? 'v' || l:mode is# "\<c-v>"
                                    let l:reset_character_selection = l:mode is? 's' || l:mode is# "\<c-s>"
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    if l:reset_visual_selection || l:reset_character_selection
                                        " If we were in a selection mode before, select the last selection.
                                        normal! gv
                            
                                        if l:reset_character_selection
                                            " Switch back to Select mode, if we were in that.
                                            normal! "\<c-g>"
                                        endif
                                    endif
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    1   0.000011   0.000003     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000036   0.000007         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000000     endif

FUNCTION  airline#parts#mode()
Called 213 times
Total time:   0.004964
 Self time:   0.001585

count  total (s)   self (s)
  213   0.004842   0.001462   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  ale#util#StartPartialTimer()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000006     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    1              0.000005     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    1              0.000001     return l:timer_id

FUNCTION  <SNR>161_process_modified_and_added()
Called 1 time
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    1              0.000001   let offset = 0
    3              0.000003   while offset < a:from_count
    2              0.000003     let line_number = a:to_line + offset
    2              0.000004     call add(a:modifications, [line_number, 'modified'])
    2              0.000002     let offset += 1
    2              0.000001   endwhile
    5              0.000004   while offset < a:to_count
    4              0.000005     let line_number = a:to_line + offset
    4              0.000007     call add(a:modifications, [line_number, 'added'])
    4              0.000004     let offset += 1
    4              0.000002   endwhile

FUNCTION  <SNR>183_UpdateLineNumbers()
Called 1 time
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
    1              0.000002     let l:line_map = {}
    1              0.000001     let l:line_numbers_changed = 0
                            
    1              0.000002     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:line_map[l:sign_id] = l:line
                                endfor
                            
   16              0.000010     for l:item in a:loclist
   15              0.000014         if l:item.bufnr == a:buffer
   15              0.000039             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
   15              0.000015             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
   15              0.000006         endif
   15              0.000006     endfor
                            
                                " When the line numbers change, sort the list again
    1              0.000001     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  <SNR>274_active()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return !empty(get(b:, 'rails_root'))

FUNCTION  <SNR>51_exists_file()
Called 4 times
Total time:   0.000234
 Self time:   0.000046

count  total (s)   self (s)
    4   0.000233   0.000045   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  airline#extensions#tagbar#currenttag()
Called 213 times
Total time:   0.006007
 Self time:   0.005127

count  total (s)   self (s)
  213              0.000567   if get(w:, 'airline_active', 0)
  213              0.000230     if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
                                endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
  213              0.000706     if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
   12   0.000982   0.000102       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   12              0.000031       let s:airline_tagbar_last_lookup_time = localtime()
   12              0.000007     endif
  213              0.000373     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  <SNR>104_update_hg_branch()
Called 213 times
Total time:   0.011808
 Self time:   0.011144

count  total (s)   self (s)
  213   0.001401   0.000737   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
  213              0.000515     let s:vcs_config['mercurial'].branch = ''
  213              0.000141   endif

FUNCTION  ale#linter#GetAll()
Called 28 times
Total time:   0.001931
 Self time:   0.001543

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
   28   0.000488   0.000099     if ale#util#InSandbox()
                                    return []
                                endif
                            
   28              0.000055     let l:combined_linters = []
                            
   84              0.000128     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   56              0.000171         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
                                    endif
                            
   56              0.000299         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   56              0.000043     endfor
                            
   28              0.000036     return l:combined_linters

FUNCTION  <SNR>159_on_stderr_nvim()
Called 1 time
Total time:   0.000058
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000057   0.000007   call self.handler.err(self.buffer)

FUNCTION  ale#linter#ResolveFiletype()
Called 28 times
Total time:   0.000758
 Self time:   0.000398

count  total (s)   self (s)
   28   0.000552   0.000192     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   28              0.000065     if type(l:filetype) isnot v:t_list
                                    return [l:filetype]
                                endif
                            
   28              0.000033     return l:filetype

FUNCTION  ale#engine#RemoveManagedFiles()
Called 1 time
Total time:   0.000387
 Self time:   0.000377

count  total (s)   self (s)
    1              0.000003     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
                                " We can't delete anything in a sandbox, so wait until we escape from
                                " it to delete temporary files and directories.
    1   0.000013   0.000003     if ale#util#InSandbox()
                                    return
                                endif
                            
                                " Delete files with a call akin to a plan `rm` command.
    1              0.000002     if has_key(l:info, 'temporary_file_list')
    1              0.000002         for l:filename in l:info.temporary_file_list
                                        call delete(l:filename)
                                    endfor
                            
    1              0.000003         let l:info.temporary_file_list = []
    1              0.000000     endif
                            
                                " Delete directories like `rm -rf`.
                                " Directories are handled differently from files, so paths that are
                                " intended to be single files can be set up for automatic deletion without
                                " accidentally deleting entire directories.
    1              0.000002     if has_key(l:info, 'temporary_directory_list')
    8              0.000011         for l:directory in l:info.temporary_directory_list
    7              0.000324             call delete(l:directory, 'rf')
    7              0.000008         endfor
                            
    1              0.000006         let l:info.temporary_directory_list = []
    1              0.000001     endif

FUNCTION  <SNR>310_EmptystackP()
Called 12 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
   12              0.000052 	exe 'let stack='.a:sname
   12              0.000051 	if match(stack,'^ *$') == 0
    8              0.000008 		return 1
                            	else
    4              0.000003 		return 0
                            	endif

FUNCTION  airline#extensions#quickfix#apply()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000006   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
                              endif

FUNCTION  <SNR>310_Push()
Called 2 times
Total time:   0.000048
 Self time:   0.000026

count  total (s)   self (s)
    2   0.000030   0.000009 	if !s:EmptystackP(a:sname)
                            		exe 'let '.a:sname."=a:el.' '.".a:sname
                            	else
    2              0.000009 		exe 'let '.a:sname.'=a:el'
    2              0.000001 	endif

FUNCTION  ale#sign#GetSignCommands()
Called 1 time
Total time:   0.000252
 Self time:   0.000252

count  total (s)   self (s)
    1              0.000001     let l:command_list = []
    1              0.000002     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    1              0.000002     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
                                    call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . ' line=1 name=ALEDummySign buffer='   . a:buffer)
                                    let l:is_dummy_sign_set = 1
                                endif
                            
                                " Place new items first.
   11              0.000016     for [l:line_str, l:info] in items(a:sign_map)
   10              0.000007         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
   25              0.000019             for l:item in l:info.items
   15              0.000018                 let l:item.sign_id = l:info.new_id
   15              0.000007             endfor
                            
   10              0.000015             if index(l:info.current_id_list, l:info.new_id) < 0
   10              0.000044                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
   10              0.000004             endif
   10              0.000004         endif
   10              0.000005     endfor
                            
                                " Remove signs without new IDs.
   11              0.000009     for l:info in values(a:sign_map)
   10              0.000010         for l:current_id in l:info.current_id_list
                                        if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . ' buffer=' . a:buffer)
                                        endif
                                    endfor
   10              0.000004     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    1              0.000002     if l:is_dummy_sign_set && !g:ale_sign_column_always
                                    call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . ' buffer=' . a:buffer)
                                endif
                            
    1              0.000001     return l:command_list

FUNCTION  <SNR>132_CreateCountDict()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
    1              0.000004     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  <SNR>132_GetCounts()
Called 112 times
Total time:   0.001661
 Self time:   0.001661

count  total (s)   self (s)
  112              0.000411     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return s:CreateCountDict()
                                endif
                            
                                " Cache is cold, so manually ask for an update.
  112              0.000286     if !has_key(g:ale_buffer_info[a:buffer], 'count')
                                    call ale#statusline#Update(a:buffer, g:ale_buffer_info[a:buffer].loclist)
                                endif
                            
  112              0.000205     return g:ale_buffer_info[a:buffer].count

FUNCTION  gitgutter#init_buffer()
Called 1 time
Total time:   0.000027
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000018   0.000004   if gitgutter#utility#is_active(a:bufnr)
                                let p = gitgutter#utility#repo_path(a:bufnr, 0)
                                if type(p) != s:t_string || empty(p)
                                  call gitgutter#utility#set_repo_path(a:bufnr)
                                  call s:setup_maps()
                                endif
                              endif

FUNCTION  <SNR>112_get_syn()
Called 3316 times
Total time:   0.141432
 Self time:   0.141432

count  total (s)   self (s)
 3316              0.008159   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
 3316              0.003601   let color = ''
 3316              0.033954   if hlexists(a:group)
 3056              0.042051     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 3056              0.002529   endif
 3316              0.007410   if empty(color) || color == -1
                                " should always exists
  262              0.004377     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  262              0.000596     if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
  262              0.000114   endif
 3316              0.003584   return color

FUNCTION  airline#extensions#branch#head()
Called 213 times
Total time:   0.065854
 Self time:   0.004181

count  total (s)   self (s)
  213              0.000582   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
  213   0.044537   0.000853   call s:update_branch()
  213   0.018814   0.000825   call s:update_untracked()
                            
  213              0.000743   if exists('b:airline_head') && !empty(b:airline_head)
  213              0.000247     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let b:airline_head .= b:buffer_vcs_config[vcs].untracked
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:(w:displayed_head_limit - 1)].(&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
                              endif
                            
                              let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
                              let b:airline_head = airline#util#shorten(b:airline_head, 120, minwidth)
                              return b:airline_head

FUNCTION  deoplete#custom#_get_filetype_option()
Called 345 times
Total time:   0.024941
 Self time:   0.010388

count  total (s)   self (s)
  345   0.004947   0.002150   let buffer_option = deoplete#custom#_get_buffer().option
  345              0.001017   if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
  345   0.014585   0.002829   let option = deoplete#custom#_get_option(a:name)
  345              0.001544   let filetype = has_key(option, a:filetype) ? a:filetype : '_'
  345              0.001175   return get(option, filetype, a:default)

FUNCTION  <SNR>125_is_skip_text()
Called 36 times
Total time:   0.007879
 Self time:   0.002943

count  total (s)   self (s)
   36              0.000224   let context = g:deoplete#_context
   36   0.003354   0.000318   let input = deoplete#util#get_input(a:event)
                            
   36              0.000263   if has_key(context, 'input') && a:event !=# 'Manual' && a:event !=# 'Async' && input ==# context.input
                                return 1
                              endif
                            
   36              0.000200   let displaywidth = strdisplaywidth(input) + 1
   36              0.000450   if &l:formatoptions =~# '[tca]' && &l:textwidth > 0     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]' || !empty(filter(deoplete#util#get_syn_names(),                  "v:val ==# 'Comment'"))
                                  return 1
                                endif
                              endif
                            
   36   0.002391   0.000490   let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
   36              0.000400   return (!pumvisible() && virtcol('.') != displaywidth) || (a:event !=# 'Manual' && input !=# ''     && index(skip_chars, input[-1:]) >= 0)

FUNCTION  <SNR>102_is_branch_empty()
Called 213 times
Total time:   0.001208
 Self time:   0.001208

count  total (s)   self (s)
  213              0.001106   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  ale#util#GetLineCount()
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  gitgutter#diff#run_diff()
Called 1 time
Total time:   0.002472
 Self time:   0.000162

count  total (s)   self (s)
    1   0.000021   0.000007   while gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                sleep 5m
                              endwhile
                            
    1   0.000015   0.000004   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
                              endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    1              0.000001   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    1              0.000003   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
    1   0.000038   0.000006   let extension = gitgutter#utility#extension(a:bufnr)
    1              0.000002   if !empty(extension)
    1              0.000003     let buff_file .= '.'.extension
    1              0.000001   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    1   0.000134   0.000010   call s:write_buffer(a:bufnr, buff_file)
                            
    1              0.000003   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    1              0.000014     let from_file = s:temp_from.'.'.a:bufnr
                            
    1              0.000002     if !empty(extension)
    1              0.000002       let from_file .= '.'.extension
    1              0.000001     endif
                            
                                " Write file from index to temporary file.
    1   0.000036   0.000007     let index_name = g:gitgutter_diff_base.':'.gitgutter#utility#repo_path(a:bufnr, 1)
    1              0.000004     let cmd .= g:gitgutter_git_executable.' --no-pager show '.index_name.' > '.from_file.' && '
                            
    1              0.000001   elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
                              endif
                            
                              " Call git-diff.
    1              0.000003   let cmd .= g:gitgutter_git_executable.' --no-pager '.g:gitgutter_git_args
    1              0.000001   if s:c_flag
    1              0.000001     let cmd .= ' -c "diff.autorefreshindex=0"'
    1              0.000001     let cmd .= ' -c "diff.noprefix=false"'
    1              0.000001     let cmd .= ' -c "core.safecrlf=false"'
    1              0.000000   endif
    1              0.000004   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    1              0.000002   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    1   0.000036   0.000006     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    1              0.000001   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    1              0.000002   let cmd .= ' || exit 0'
                            
    1              0.000001   let cmd .= ')'
                            
    1   0.000110   0.000009   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    1   0.000010   0.000008   if g:gitgutter_async && gitgutter#async#available()
    1   0.001988   0.000020     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    1              0.000003     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>127_GetNearbyTag()
Called 12 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
   12              0.000015     if s:nearby_disabled
   12              0.000015         return {}
                                endif
                            
                                let fileinfo = tagbar#state#get_current_file(a:forcecurrent)
                                if empty(fileinfo)
                                    return {}
                                endif
                            
                                let typeinfo = fileinfo.typeinfo
                                if a:0 > 0
                                    let curline = a:1
                                else
                                    let curline = line('.')
                                endif
                                let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
                                for line in range(curline, 1, -1)
                                    if has_key(fileinfo.fline, line)
                                        let curtag = fileinfo.fline[line]
                                        if a:all || typeinfo.getKind(curtag.fields.kind).stl
                                            let tag = curtag
                                            break
                                        endif
                                    endif
                                endfor
                            
                                return tag

FUNCTION  gitgutter#hunk#increment_lines_removed()
Called 1 time
Total time:   0.000028
 Self time:   0.000008

count  total (s)   self (s)
    1   0.000013   0.000003   let summary = gitgutter#hunk#summary(a:bufnr)
    1              0.000001   let summary[2] += a:count
    1   0.000013   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ale#handlers#eslint#GetExecutable()
Called 14 times
Total time:   0.004280
 Self time:   0.000117

count  total (s)   self (s)
   14   0.004270   0.000107     return ale#node#FindExecutable(a:buffer, 'javascript_eslint', [   'node_modules/.bin/eslint_d',   'node_modules/eslint/bin/eslint.js',   'node_modules/.bin/eslint',])

FUNCTION  <SNR>81_Debug()
Called 32 times
Total time:   0.000255
 Self time:   0.000255

count  total (s)   self (s)
                              " Arguments: First argument is always a level value                                (Debug)
                              " Subsequent arguments can be any type.                                            (Debug)
                              " If they are a string, and that string represents the name of a global            (Debug)
                              " variable, the variable name, and it's value, will be printed.                    (Debug)
                              " Lists and dictionaries should be handled.                                        (Debug)
   32              0.000104   if !exists('g:Debug') || g:Debug < a:level                                       " (Debug)
   32              0.000041     return " (Debug) "
                              endif                                                                            " (Debug)
                                                                                                               " (Debug)
                              let s = ''                                                                       " (Debug)
                              let i = 1                                                                        " (Debug)
                              while i <= a:0                                                                   " (Debug)
                                if exists('DebugArg')                                                          " (Debug)
                                  unlet DebugArg                                                               " (Debug)
                                endif                                                                          " (Debug)
                                exec "let DebugArg = a:" . i
                                let argType = type(DebugArg)                                                   " (Debug)
                                if argType == 1  " String                                                        (Debug)
                                  " String may be a variable name, in which case we print the name first         (Debug)
                                  if exists(DebugArg)                                                          " (Debug)
                                    " The string is indeed the name of a variable                                (Debug)
                                    " Get the name of the variable, then set DebugArg to the value of that variable
                                    let s = s . DebugArg . " = "                                               " (Debug)
                                    exec 'let arg2 = ' . DebugArg
                                    unlet DebugArg                                                             " (Debug)
                                    let DebugArg = arg2   " Necessary to change the type of DebugArg             (Debug)
                                  endif                                                                        " (Debug)
                                endif                                                                          " (Debug)
                                " Now print the value itself                                                     (Debug)
                                let s = s . string(DebugArg)                                                   " (Debug)
                                if i < a:0                                                                     " (Debug)
                                  let s = s . ', '                                                             " (Debug)
                                endif                                                                          " (Debug)
                                let i = i + 1                                                                  " (Debug)
                              endwhile                                                                         " (Debug)
                              autocmd! CursorHold * echom '--------- Debug ---------'
                              let g:DebugEcho = 'echom'
                              exec g:DebugEcho . ' s'

FUNCTION  airline#extensions#wordcount#apply()
Called 1 time
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    1              0.000010   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes', s:filetypes)
                            
                              " Check if filetype needs testing
    1              0.000007   if did_filetype() || filetypes isnot s:filetypes
                                let s:filetypes = filetypes
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
                              endif
                            
    1              0.000006   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
                              endif

FUNCTION  <SNR>174_CheckForBadConfig()
Called 1 time
Total time:   0.000379
 Self time:   0.000379

count  total (s)   self (s)
    1              0.000004     let l:config_error_pattern = '\v^ESLint couldn''t find a configuration file'   . '|^Cannot read config file'   . '|^.*Configuration for rule .* is invalid'   . '|^ImportDeclaration should appear'
                            
                                " Look for a message in the first few lines which indicates that
                                " a configuration file couldn't be found.
   12              0.000013     for l:line in a:lines[:10]
   11              0.000285         let l:match = matchlist(l:line, l:config_error_pattern)
                            
   11              0.000014         if len(l:match) > 0
                                        " Don't show the missing config error if we've disabled it.
                                        if ale#Var(a:buffer, 'javascript_eslint_suppress_missing_config')&& l:match[0] is# 'ESLint couldn''t find a configuration file'
                                            return 0
                                        endif
                            
                                        return 1
                                    endif
   11              0.000005     endfor
                            
    1              0.000001     return 0

FUNCTION  ale#util#GetMatches()
Called 16 times
Total time:   0.001473
 Self time:   0.001473

count  total (s)   self (s)
   16              0.000018     let l:matches = []
   16              0.000042     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
   16              0.000041     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
   48              0.000042     for l:line in l:lines
   96              0.000083         for l:pattern in l:patterns
   79              0.000700             let l:match = matchlist(l:line, l:pattern)
                            
   79              0.000092             if !empty(l:match)
   15              0.000021                 call add(l:matches, l:match)
   15              0.000008                 break
                                        endif
   64              0.000028         endfor
   32              0.000014     endfor
                            
   16              0.000014     return l:matches

FUNCTION  deoplete#custom#_get_source_vars()
Called 81 times
Total time:   0.003561
 Self time:   0.001535

count  total (s)   self (s)
   81   0.002150   0.000607   let global_vars = get(deoplete#custom#_get_source(a:name), 'vars', {})
   81   0.000948   0.000465   let buffer_vars = get(deoplete#custom#_get_buffer().source_vars, a:name, {})
   81              0.000382   return extend(copy(global_vars), buffer_vars)

FUNCTION  <SNR>162_upsert_new_gitgutter_signs()
Called 1 time
Total time:   0.000250
 Self time:   0.000210

count  total (s)   self (s)
    1   0.000011   0.000004   let other_signs         = gitgutter#utility#getbufvar(a:bufnr, 'other_signs')
    1   0.000009   0.000004   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
                            
                              " Handle special case where the first line is the site of two hunks:
                              " lines deleted above at the start of the file, and lines deleted
                              " immediately below.
    1              0.000004   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                let modified_lines = [[1, 'removed_above_and_below']] + a:modified_lines[2:]
                              else
    1              0.000002     let modified_lines = a:modified_lines
    1              0.000000   endif
                            
   11              0.000008   for line in modified_lines
   10              0.000013     let line_number = line[0]  " <number>
   10              0.000016     if index(other_signs, line_number) == -1  " don't clobber others' signs
    5   0.000049   0.000021       let name = s:highlight_name_for_change(line[1])
    5              0.000010       if !has_key(old_gitgutter_signs, line_number)  " insert
                                    let id = s:next_sign_id()
                                    execute "sign place" id "line=" . line_number "name=" . name "buffer=" . a:bufnr
                                  else  " update if sign has changed
    5              0.000009         let old_sign = old_gitgutter_signs[line_number]
    5              0.000006         if old_sign.name !=# name
                                      execute "sign place" old_sign.id "name=" . name "buffer=" . a:bufnr
                                    end
    5              0.000002       endif
    5              0.000002     endif
   10              0.000006   endfor
                              " At this point b:gitgutter_gitgutter_signs is out of date.

FUNCTION  <SNR>131_GatherOutput()
Called 17 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
   17              0.000081     if has_key(s:job_info_map, a:job_id)
   17              0.000119         call add(s:job_info_map[a:job_id].output, a:line)
   17              0.000021     endif

FUNCTION  airline#statusline()
Called 245 times
Total time:   0.003775
 Self time:   0.003775

count  total (s)   self (s)
  245              0.001364   if has_key(s:contexts, a:winnr)
  245              0.002084     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>183_BuildSignMap()
Called 1 time
Total time:   0.000702
 Self time:   0.000290

count  total (s)   self (s)
    1   0.000013   0.000004     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    1              0.000001     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
    1              0.000002         let l:selected_grouped_items = a:grouped_items
    1              0.000000     endif
                            
    1              0.000001     let l:sign_map = {}
    1              0.000002     let l:sign_offset = g:ale_sign_offset
                            
    1              0.000002     for [l:line, l:sign_id, l:name] in a:current_sign_list
                                    let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
                                    if l:sign_id > l:sign_offset
                                        let l:sign_offset = l:sign_id
                                    endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
                                    call add(l:sign_info.current_id_list, l:sign_id)
                                    call add(l:sign_info.current_name_list, l:name)
                            
                                    let l:sign_map[l:line] = l:sign_info
                                endfor
                            
   11              0.000009     for l:group in l:selected_grouped_items
   10              0.000014         let l:line = l:group[0].lnum
   10              0.000049         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
   10   0.000440   0.000038         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
   10              0.000012         let l:sign_info.items = l:group
                            
   10              0.000022         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
   10              0.000008         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
                                        let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
                                    else
                                        " This sign name replaces the previous name, so use a new ID.
   10              0.000014             let l:sign_info.new_id = l:sign_offset + 1
   10              0.000011             let l:sign_offset += 1
   10              0.000004         endif
                            
   10              0.000018         let l:sign_map[l:line] = l:sign_info
   10              0.000005     endfor
                            
    1              0.000001     return l:sign_map

FUNCTION  gitgutter#utility#is_active()
Called 7 times
Total time:   0.000679
 Self time:   0.000095

count  total (s)   self (s)
    7   0.000674   0.000090   return g:gitgutter_enabled && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  airline#extensions#apply()
Called 1 time
Total time:   0.000731
 Self time:   0.000131

count  total (s)   self (s)
                            
    1   0.000118   0.000016   if s:is_excluded_window()
                                return -1
                              endif
                            
    1              0.000004   if &buftype == 'help'
                                call airline#extensions#apply_left_override('Help', '%f')
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
                              endif
                            
    1              0.000003   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
                              endif
                            
    1              0.000013   if has_key(s:filetype_overrides, &ft)
    1              0.000012     let args = s:filetype_overrides[&ft]
    1   0.000523   0.000025     call airline#extensions#apply_left_override(args[0], args[1])
    1              0.000001   endif
                            
    1              0.000007   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
                              endfor

FUNCTION  airline#builder#should_change_group()
Called 2 times
Total time:   0.001787
 Self time:   0.000101

count  total (s)   self (s)
    2              0.000007   if a:group1 == a:group2
                                return 0
                              endif
    2   0.000899   0.000026   let color1 = airline#highlighter#get_highlight(a:group1)
    2   0.000839   0.000025   let color2 = airline#highlighter#get_highlight(a:group2)
    2              0.000007   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
                              else
    2              0.000012     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  ale#cursor#EchoCursorWarning()
Called 3 times
Total time:   0.000356
 Self time:   0.000135

count  total (s)   self (s)
    3              0.000024     let l:buffer = bufnr('')
                            
    3              0.000010     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    3              0.000010     if mode(1) isnot# 'n'
    1              0.000001         return
                                endif
                            
    2   0.000201   0.000023     if ale#ShouldDoNothing(l:buffer)
    1              0.000000         return
                                endif
                            
    1   0.000054   0.000012     let [l:info, l:loc] = s:FindItemAtCursor(l:buffer)
                            
    1              0.000001     if g:ale_echo_cursor
    1              0.000002         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
    1              0.000001     endif
                            
    1              0.000001     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  <SNR>135_StopCursorTimer()
Called 11 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   11              0.000013     if s:cursor_timer != -1
    3              0.000006         call timer_stop(s:cursor_timer)
    3              0.000004         let s:cursor_timer = -1
    3              0.000001     endif

FUNCTION  airline#highlighter#get_highlight()
Called 1658 times
Total time:   0.283432
 Self time:   0.128251

count  total (s)   self (s)
 1658              0.045278   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
 1658              0.006086   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
 1658   0.082161   0.009979     let fg = s:get_syn(a:group, 'fg')
 1658   0.077498   0.008248     let bg = s:get_syn(a:group, 'bg')
 1658              0.020845     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
 1658              0.002916     let opts = a:000
 1658              0.001599     if bold
  323              0.000553       let opts = ['bold']
  323              0.000216     endif
 1658   0.025421   0.011672     let res = reverse ? s:get_array(bg, fg, opts) : s:get_array(fg, bg, opts)
 1658              0.001047   endif
 1658              0.004794   let s:hl_groups[a:group] = res
 1658              0.001362   return res

FUNCTION  deoplete#util#has_yarp()
Called 27 times
Total time:   0.001489
 Self time:   0.000398

count  total (s)   self (s)
   27   0.001472   0.000381   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  ale#history#Add()
Called 7 times
Total time:   0.000537
 Self time:   0.000537

count  total (s)   self (s)
    7              0.000019     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
    7              0.000037     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
    7              0.000021     if len(l:history) >= g:ale_max_buffer_history_size
    7              0.000127         let l:history = l:history[1:]
    7              0.000005     endif
                            
    7              0.000079     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
    7              0.000187     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  ale#util#JoinNeovimOutput()
Called 15 times
Total time:   0.001103
 Self time:   0.000861

count  total (s)   self (s)
   15              0.000029     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
                                endif
                            
   15              0.000069     let l:lines = a:data[:-2]
                            
   15              0.000038     if len(a:data) > 1
    1              0.000011         let l:lines[0] = a:last_line . l:lines[0]
    1              0.000005         let l:new_last_line = a:data[-1]
    1              0.000002     else
   14              0.000073         let l:new_last_line = a:last_line . get(a:data, 0, '')
   14              0.000012     endif
                            
   32              0.000082     for l:line in l:lines
   17   0.000407   0.000164         call a:callback(a:job, l:line)
   17              0.000021     endfor
                            
   15              0.000028     return l:new_last_line

FUNCTION  airline#util#shorten()
Called 426 times
Total time:   0.006135
 Self time:   0.006135

count  total (s)   self (s)
  426              0.001647   if winwidth(0) < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
                              else
  426              0.000487     return a:text
                              endif

FUNCTION  <SNR>90_StringifyOpts()
Called 1 time
Total time:   0.000194
 Self time:   0.000194

count  total (s)   self (s)
    1              0.000004   let rv = []
    8              0.000019   for key in a:keys
    7              0.000028     if has_key(a:opts, key)
                                  call add(rv, ' -'.key)
                                  let val = a:opts[key]
                                  if type(val) != type('') || val != ''
                                    call add(rv, '='.val)
                                  endif
                                endif
    7              0.000012   endfor
    1              0.000005   return join(rv, '')

FUNCTION  <SNR>112_hl_group_exists()
Called 937 times
Total time:   0.024233
 Self time:   0.024233

count  total (s)   self (s)
  937              0.010090   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  937              0.000719   return 1

FUNCTION  ale#job#PrepareCommand()
Called 7 times
Total time:   0.000787
 Self time:   0.000640

count  total (s)   self (s)
    7   0.000399   0.000252     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
    7              0.000042     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    7              0.000027     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
    7              0.000121     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
                                endif
                            
    7              0.000123     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  airline#extensions#branch#get_head()
Called 213 times
Total time:   0.069934
 Self time:   0.004080

count  total (s)   self (s)
  213   0.066792   0.000937   let head = airline#extensions#branch#head()
  213              0.000763   let empty_message = get(g:, 'airline#extensions#branch#empty_message', '')
  213              0.000797   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  213              0.001361   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  deoplete#util#vimoption2python_not()
Called 1 time
Total time:   0.000416
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000415   0.000009   return '[^\w' . s:vimoption2python(a:option) . ']'

FUNCTION  <SNR>310_InComment()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000019 	return synIDattr(synID(line('.'), col('.'), 0), 'name') =~ 'Comment\|String'

FUNCTION  ale#lsp_linter#CheckWithLSP()
Called 7 times
Total time:   0.003963
 Self time:   0.000110

count  total (s)   self (s)
    7              0.000024     let l:info = g:ale_buffer_info[a:buffer]
    7   0.003906   0.000053     let l:lsp_details = ale#lsp_linter#StartLSP(a:buffer, a:linter)
                            
    7              0.000014     if empty(l:lsp_details)
    7              0.000007         return 0
                                endif
                            
                                let l:id = l:lsp_details.connection_id
                            
                                " Register a callback now for handling errors now.
                                let l:Callback = function('ale#lsp_linter#HandleLSPResponse')
                                call ale#lsp#RegisterCallback(l:id, l:Callback)
                            
                                " Remember the linter this connection is for.
                                let s:lsp_linter_map[l:id] = a:linter.name
                            
                                if a:linter.lsp is# 'tsserver'
                                    let l:message = ale#lsp#tsserver_message#Geterr(a:buffer)
                                    let l:notified = ale#lsp#Send(l:id, l:message) != 0
                                else
                                    let l:notified = ale#lsp#NotifyForChanges(l:id, a:buffer)
                                endif
                            
                                " If this was a file save event, also notify the server of that.
                                if a:linter.lsp isnot# 'tsserver'&& getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    let l:save_message = ale#lsp#message#DidSave(a:buffer)
                                    let l:notified = ale#lsp#Send(l:id, l:save_message) != 0
                                endif
                            
                                if l:notified
                                    if index(l:info.active_linter_list, a:linter.name) < 0
                                        call add(l:info.active_linter_list, a:linter.name)
                                    endif
                                endif
                            
                                return l:notified

FUNCTION  <SNR>184_BufWinId()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     return exists('*bufwinid') ? bufwinid(str2nr(a:buffer)) : 0

FUNCTION  <SNR>59_refresh()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000005   let &updatetime = a:updatetime
    1              0.000008   autocmd bufferline CursorHold * call s:cursorhold_callback()

FUNCTION  deoplete#custom#_get_source()
Called 81 times
Total time:   0.001543
 Self time:   0.000992

count  total (s)   self (s)
   81   0.000905   0.000354   let custom = deoplete#custom#_get().source
                            
   81              0.000202   if !has_key(custom, a:source_name)
                                let custom[a:source_name] = {}
                              endif
                            
   81              0.000165   return custom[a:source_name]

FUNCTION  <SNR>59_echo()
Called 6 times
Total time:   0.002729
 Self time:   0.000436

count  total (s)   self (s)
    6              0.000014   if &filetype ==# 'unite'
                                return
                              endif
                            
    6   0.002323   0.000030   let line = bufferline#get_echo_string()
                            
                              " 12 is magical and is the threshold for when it doesn't wrap text anymore
    6              0.000012   let width = &columns - 12
    6              0.000007   if g:bufferline_rotate == 2
                                let current_buffer_start = stridx(line, g:bufferline_active_buffer_left)
                                let current_buffer_end = stridx(line, g:bufferline_active_buffer_right)
                                if current_buffer_start < s:window_start
                                  let s:window_start = current_buffer_start
                                endif
                                if current_buffer_end > (s:window_start + width)
                                  let s:window_start = current_buffer_end - width + 1
                                endif
                                let line = strpart(line, s:window_start, width)
                              else
    6              0.000013     let line = strpart(line, 0, width)
    6              0.000003   endif
                            
    6              0.000228   echo line
                            
    6              0.000012   if &updatetime != s:updatetime
    1              0.000005     let &updatetime = s:updatetime
    1              0.000001   endif

FUNCTION  gitgutter#utility#getbufvar()
Called 229 times
Total time:   0.002368
 Self time:   0.002368

count  total (s)   self (s)
  229              0.001133   let dict = get(getbufvar(a:buffer, ''), 'gitgutter', {})
  229              0.000565   if has_key(dict, a:varname)
  229              0.000454     return dict[a:varname]
                              else
                                if a:0
                                  return a:1
                                endif
                              endif

FUNCTION  AutoPairsTryInit()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   if exists('b:autopairs_loaded')
    1              0.000001     return
                              end
                            
                              " for auto-pairs starts with 'a', so the priority is higher than supertab and vim-endwise
                              "
                              " vim-endwise doesn't support <Plug>AutoPairsReturn
                              " when use <Plug>AutoPairsReturn will cause <Plug> isn't expanded
                              "
                              " supertab doesn't support <SID>AutoPairsReturn
                              " when use <SID>AutoPairsReturn  will cause Duplicated <CR>
                              "
                              " and when load after vim-endwise will cause unexpected endwise inserted.
                              " so always load AutoPairs at last
                            
                              " Buffer level keys mapping
                              " comptible with other plugin
                              if g:AutoPairsMapCR
                                if v:version == 703 && has('patch32') || v:version > 703
                                  " VIM 7.3 supports advancer maparg which could get <expr> info
                                  " then auto-pairs could remap <CR> in any case.
                                  let info = maparg('<CR>', 'i', 0, 1)
                                  if empty(info)
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = info['rhs']
                                    let old_cr = s:ExpandMap(old_cr)
                                    let old_cr = substitute(old_cr, '<SID>', '<SNR>' . info['sid'] . '_', 'g')
                                    let is_expr = info['expr']
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper73'
                                  endif
                                else
                                  " VIM version less than 7.3
                                  " the mapping's <expr> info is lost, so guess it is expr or not, it's
                                  " not accurate.
                                  let old_cr = maparg('<CR>', 'i')
                                  if old_cr == ''
                                    let old_cr = '<CR>'
                                    let is_expr = 0
                                  else
                                    let old_cr = s:ExpandMap(old_cr)
                                    " old_cr contain (, I guess the old cr is in expr mode
                                    let is_expr = old_cr =~ '\V(' && toupper(old_cr) !~ '\V<C-R>'
                            
                                    " The old_cr start with " it must be in expr mode
                                    let is_expr = is_expr || old_cr =~ '\v^"'
                                    let wrapper_name = '<SID>AutoPairsOldCRWrapper'
                                  end
                                end
                            
                                if old_cr !~ 'AutoPairsReturn'
                                  if is_expr
                                    " remap <expr> to `name` to avoid mix expr and non-expr mode
                                    execute 'inoremap <buffer> <expr> <script> '. wrapper_name . ' ' . old_cr
                                    let old_cr = wrapper_name
                                  end
                                  " Always silent mapping
                                  execute 'inoremap <script> <buffer> <silent> <CR> '.old_cr.'<SID>AutoPairsReturn'
                                end
                              endif
                              call AutoPairsInit()

FUNCTION  airline#util#prepend()
Called 639 times
Total time:   0.003975
 Self time:   0.003975

count  total (s)   self (s)
  639              0.001217   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  639              0.001679   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 11 times
Total time:   0.000497
 Self time:   0.000380

count  total (s)   self (s)
   11              0.000029     let l:buffer = bufnr('')
                            
   11              0.000020     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   11              0.000022     if mode(1) isnot# 'n'
                                    return
                                endif
                            
   11   0.000112   0.000051     call s:StopCursorTimer()
                            
   11              0.000041     let l:pos = getcurpos()[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   11              0.000020     if l:pos != s:last_pos
    3   0.000084   0.000029         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    3              0.000013         let s:last_pos = l:pos
    3              0.000026         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    3              0.000003     endif

FUNCTION  <lambda>61()
Called 7 times
Total time:   0.001799
 Self time:   0.000082

count  total (s)   self (s)
    7   0.001795   0.000078 return ale#node#FindExecutable(buf, a:base_var_name, a:path_list)

FUNCTION  <SNR>86_Highlight_Matching_Pair()
Called 23 times
Total time:   0.015798
 Self time:   0.015798

count  total (s)   self (s)
                              " Remove any previous match.
   23              0.000083   if exists('w:paren_hl_on') && w:paren_hl_on
    9              0.000027     silent! call matchdelete(3)
    9              0.000015     let w:paren_hl_on = 0
    9              0.000005   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   23              0.000083   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   23              0.000057   let c_lnum = line('.')
   23              0.000048   let c_col = col('.')
   23              0.000030   let before = 0
                            
   23              0.000067   let text = getline(c_lnum)
   23              0.000374   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   23              0.000051   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
   23              0.000096     let [c_before, c] = matches[1:2]
   23              0.000017   endif
   23              0.000305   let plist = split(&matchpairs, '.\zs[:,]')
   23              0.000076   let i = index(plist, c)
   23              0.000027   if i < 0
                                " not found, in Insert mode try character before the cursor
   14              0.000050     if c_col > 1 && (mode() == 'i' || mode() == 'R')
   14              0.000043       let before = strlen(c_before)
   14              0.000024       let c = c_before
   14              0.000037       let i = index(plist, c)
   14              0.000012     endif
   14              0.000015     if i < 0
                                  " not found, nothing to do
   12              0.000012       return
                                endif
    2              0.000001   endif
                            
                              " Figure out the arguments for searchpairpos().
   11              0.000013   if i % 2 == 0
    9              0.000012     let s_flags = 'nW'
    9              0.000021     let c2 = plist[i + 1]
    9              0.000005   else
    2              0.000003     let s_flags = 'nbW'
    2              0.000004     let c2 = c
    2              0.000005     let c = plist[i - 1]
    2              0.000001   endif
   11              0.000013   if c == '['
    3              0.000003     let c = '\['
    3              0.000002     let c2 = '\]'
    3              0.000001   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   11              0.000012   if before > 0
    2              0.000010     let has_getcurpos = exists("*getcurpos")
    2              0.000003     if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
    2              0.000010       let save_cursor = getcurpos()
    2              0.000002     else
                                  let save_cursor = winsaveview()
                                endif
    2              0.000009     call cursor(c_lnum, c_col - before)
    2              0.000002   endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
   11              0.000041   let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
   11              0.000976   execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
   11              0.000034   let stoplinebottom = line('w$')
   11              0.000027   let stoplinetop = line('w0')
   11              0.000014   if i % 2 == 0
    9              0.000021     let stopline = stoplinebottom
    9              0.000006   else
    2              0.000005     let stopline = stoplinetop
    2              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   11              0.000025   if mode() == 'i' || mode() == 'R'
    3              0.000018     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    3              0.000002   else
    8              0.000029     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    8              0.000004   endif
   11              0.000018   try
   11              0.011178     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   11              0.000020   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   11              0.000013   if before > 0
    2              0.000002     if has_getcurpos
    2              0.000006       call setpos('.', save_cursor)
    2              0.000001     else
                                  call winrestview(save_cursor)
                                endif
    2              0.000001   endif
                            
                              " If a match is found setup match highlighting.
   11              0.000027   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    9              0.000020     if exists('*matchaddpos')
    9              0.000326       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
    9              0.000010     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
    9              0.000018     let w:paren_hl_on = 1
    9              0.000006   endif

FUNCTION  GetVueIndent()
Called 1 time
Total time:   0.001537
 Self time:   0.000356

count  total (s)   self (s)
    6              0.000031   for language in s:languages
    5              0.000177     let opening_tag_line = searchpair(language.pairs[0], '', language.pairs[1], 'bWr')
                            
    5              0.000014     if opening_tag_line
                                  execute 'let indent = ' . get(language, 'indentexpr', -1)
                                  break
                                endif
    5              0.000009   endfor
                            
    1              0.000006   if exists('l:indent')
                                if (opening_tag_line == prevnonblank(v:lnum - 1) || opening_tag_line == v:lnum) || getline(v:lnum) =~ '\v^\s*\</(script|style|template)'
                                  return 0
                                endif
                              else
                                " Couldn't find language, fall back to html
    1   0.001210   0.000029     execute 'let indent = ' . s:html_indent
    1              0.000001   endif
                            
    1              0.000002   return indent

FUNCTION  <SNR>49_NERDTreeGetFileGitStatusKey()
Called 51 times
Total time:   0.000466
 Self time:   0.000466

count  total (s)   self (s)
   51              0.000171     if a:us ==# '?' && a:them ==# '?'
   24              0.000036         return 'Untracked'
                                elseif a:us ==# ' ' && a:them ==# 'M'
   27              0.000050         return 'Modified'
                                elseif a:us =~# '[MAC]'
                                    return 'Staged'
                                elseif a:us ==# 'R'
                                    return 'Renamed'
                                elseif a:us ==# 'U' || a:them ==# 'U' || a:us ==# 'A' && a:them ==# 'A' || a:us ==# 'D' && a:them ==# 'D'
                                    return 'Unmerged'
                                elseif a:them ==# 'D'
                                    return 'Deleted'
                                elseif a:us ==# '!'
                                    return 'Ignored'
                                else
                                    return 'Unknown'
                                endif

FUNCTION  gitgutter#hunk#set_hunks()
Called 1 time
Total time:   0.000041
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000022   0.000006   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    1   0.000019   0.000003   call s:reset_summary(a:bufnr)

FUNCTION  deoplete#mapping#_set_completeopt()
Called 10 times
Total time:   0.000238
 Self time:   0.000216

count  total (s)   self (s)
   10              0.000034   if exists('g:deoplete#_saved_completeopt')
    6              0.000006     return
                              endif
    4              0.000019   let g:deoplete#_saved_completeopt = &completeopt
    4   0.000059   0.000047   set completeopt-=longest
    4   0.000022   0.000018   set completeopt+=menuone
    4   0.000016   0.000014   set completeopt-=menu
    4              0.000031   if &completeopt !~# 'noinsert\|noselect'
    4   0.000023   0.000019     set completeopt+=noselect
    4              0.000003   endif

FUNCTION  <SNR>127_IsValidFile()
Called 6 times
Total time:   0.000650
 Self time:   0.000594

count  total (s)   self (s)
    6   0.000047   0.000022     call tagbar#debug#log('Checking if file is valid [' . a:fname . ']')
                            
    6              0.000009     if a:fname == '' || a:ftype == ''
                                    call tagbar#debug#log('Empty filename or type')
                                    return 0
                                endif
                            
    6              0.000289     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
    2   0.000018   0.000009         call tagbar#debug#log('File not readable')
    2              0.000002         return 0
                                endif
                            
    4              0.000061     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call tagbar#debug#log('File is marked as ignored')
                                    return 0
                                endif
                            
    4              0.000054     let winnr = bufwinnr(a:fname)
    4              0.000014     if winnr != -1 && getwinvar(winnr, '&diff')
                                    call tagbar#debug#log('Window is in diff mode')
                                    return 0
                                endif
                            
    4              0.000004     if &previewwindow
                                    call tagbar#debug#log('In preview window')
                                    return 0
                                endif
                            
    4              0.000014     if !has_key(s:known_types, a:ftype)
    4              0.000010         if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
    4   0.000039   0.000018             call tagbar#debug#log('Unsupported filetype: ' . a:ftype)
    4              0.000004             return 0
                                    endif
                                endif
                            
                                return 1

FUNCTION  <SNR>162_obsolete_gitgutter_signs_to_remove()
Called 1 time
Total time:   0.000094
 Self time:   0.000087

count  total (s)   self (s)
    1              0.000002   let signs_to_remove = []  " list of [<id (number)>, ...]
    1              0.000001   let remove_all_signs = 1
    1   0.000011   0.000004   let old_gitgutter_signs = gitgutter#utility#getbufvar(a:bufnr, 'gitgutter_signs')
   10              0.000010   for line_number in keys(old_gitgutter_signs)
    9              0.000022     if index(a:new_gitgutter_signs_line_numbers, str2nr(line_number)) == -1
                                  call add(signs_to_remove, old_gitgutter_signs[line_number].id)
                                else
    9              0.000009       let remove_all_signs = 0
    9              0.000004     endif
    9              0.000004   endfor
    1              0.000003   let s:remove_all_old_signs = remove_all_signs
    1              0.000001   return signs_to_remove

FUNCTION  ale#engine#HandleLoclist()
Called 1 time
Total time:   0.006120
 Self time:   0.000094

count  total (s)   self (s)
    1              0.000003     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    1              0.000001     if empty(l:info)
                                    return
                                endif
                            
    1              0.000001     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    1              0.000003         call filter(l:info.active_linter_list, 'v:val isnot# a:linter_name')
    1              0.000000     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    1   0.001126   0.000010     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    1              0.000004     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    1              0.000002     if !empty(l:linter_loclist)
                                    " Add the new items.
    1              0.000002         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    1   0.000415   0.000047         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    1              0.000000     endif
                            
    1   0.000081   0.000003     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
    1   0.004471   0.000006     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  airline#util#exec_funcrefs()
Called 1 time
Total time:   0.001854
 Self time:   0.000199

count  total (s)   self (s)
    6              0.000022     for Fn in a:list
    6   0.001785   0.000130       let code = call(Fn, a:000)
    6              0.000015       if code != 0
    1              0.000002         return code
                                  endif
    5              0.000007     endfor
                                return 0

FUNCTION  remote#host#Require()
Called 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000007   if !has_key(s:hosts, a:name)
                                throw 'No host named "'.a:name.'" is registered'
                              endif
    1              0.000007   let host = s:hosts[a:name]
    1              0.000004   if !host.channel && !host.initialized
                                let host_info = { 'name': a:name, 'orig_name': get(host, 'orig_name', a:name) }
                                let host.channel = call(host.factory, [host_info])
                                let host.initialized = 1
                              endif
    1              0.000003   return host.channel

FUNCTION  gitgutter#process_buffer()
Called 6 times
Total time:   0.003417
 Self time:   0.000203

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    6   0.000696   0.000031   if gitgutter#utility#is_active(a:bufnr)
    4   0.000104   0.000027     if a:force || s:has_fresh_changes(a:bufnr)
                            
    1              0.000001       let diff = ''
    1              0.000001       try
    1   0.002489   0.000017         let diff = gitgutter#diff#run_diff(a:bufnr, 'index', 0)
    1              0.000002       catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
                                  endtry
                            
    1              0.000003       if diff != 'async'
                                    call gitgutter#diff#handler(a:bufnr, diff)
                                  endif
                            
    1              0.000001     endif
    4              0.000002   endif

FUNCTION  ale#handlers#eslint#GetCommand()
Called 7 times
Total time:   0.002796
 Self time:   0.000163

count  total (s)   self (s)
    7   0.002252   0.000040     let l:executable = ale#handlers#eslint#GetExecutable(a:buffer)
                            
    7   0.000151   0.000043     let l:options = ale#Var(a:buffer, 'javascript_eslint_options')
                            
    7   0.000380   0.000066     return ale#node#Executable(a:buffer, l:executable)   . (!empty(l:options) ? ' ' . l:options : '')   . ' -f unix --stdin --stdin-filename %s'

FUNCTION  bufferline#refresh_status()
Called 213 times
Total time:   0.148440
 Self time:   0.003578

count  total (s)   self (s)
  213              0.000400   if g:bufferline_solo_highlight
                                if g:bufferline_status_info.count == 1
                                  exec printf('highlight! link %s %s', g:bufferline_active_highlight, g:bufferline_inactive_highlight)
                                else
                                  exec printf('highlight! link %s NONE', g:bufferline_active_highlight)
                                endif
                              endif
  213   0.145902   0.001040   call bufferline#get_echo_string()
  213              0.000151   return ''

FUNCTION  252()
Called 4 times
Total time:   0.045096
 Self time:   0.000781

count  total (s)   self (s)
    4              0.000049     setlocal noreadonly modifiable
                            
                                " remember the top line of the buffer and the current line so we can
                                " restore the view exactly how it was
    4              0.000012     let curLine = line(".")
    4              0.000008     let curCol = col(".")
    4              0.000008     let topLine = line("w0")
                            
                                " delete all lines in the buffer (being careful not to clobber a register)
    4              0.000167     silent 1,$delete _
                            
    4   0.000554   0.000026     call self._dumpHelp()
                            
                                " delete the blank line before the help and add one after it
    4   0.000023   0.000016     if !self.isMinimal()
    4              0.000019         call setline(line(".")+1, "")
    4              0.000013         call cursor(line(".")+1, col("."))
    4              0.000002     endif
                            
    4   0.000027   0.000014     if self.getShowBookmarks()
                                    call self._renderBookmarks()
                                endif
                            
                                " add the 'up a dir' line
    4   0.000016   0.000011     if !self.isMinimal()
    4   0.000031   0.000025         call setline(line(".")+1, s:UI.UpDirLine())
    4              0.000010         call cursor(line(".")+1, col("."))
    4              0.000002     endif
                            
                                " draw the header line
    4   0.001155   0.000035     let header = self.nerdtree.root.path.str({'format': 'UI', 'truncateTo': winwidth(0)})
    4              0.000015     call setline(line(".")+1, header)
    4              0.000010     call cursor(line(".")+1, col("."))
                            
                                " draw the tree
    4   0.042730   0.000093     silent put =self.nerdtree.root.renderToString()
                            
                                " delete the blank line at the top of the buffer
    4              0.000028     silent 1,1delete _
                            
                                " restore the view
    4              0.000015     let old_scrolloff=&scrolloff
    4              0.000024     let &scrolloff=0
    4              0.000012     call cursor(topLine, 1)
    4              0.000066     normal! zt
    4              0.000009     call cursor(curLine, curCol)
    4              0.000013     let &scrolloff = old_scrolloff
                            
    4              0.000019     setlocal readonly nomodifiable

FUNCTION  airline#util#append()
Called 1491 times
Total time:   0.013823
 Self time:   0.013823

count  total (s)   self (s)
 1491              0.002968   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1491              0.004028   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
 1491              0.004052   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  HtmlIndent_FindTagStart()
Called 1 time
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                              "{{{
                              " Avoids using the indent of a continuation line.
                              " Moves the cursor.
                              " Return two values:
                              " - the matching line number or "lnum".
                              " - a flag indicating whether we found the end of a tag.
                              " This method is global so that HTML-like indenters can use it.
                              " To avoid matching " > " or " < " inside a string require that the opening
                              " "<" is followed by a word character and the closing ">" comes after a
                              " non-white character.
    1              0.000016   let idx = match(getline(a:lnum), '\S>\s*$')
    1              0.000003   if idx > 0
                                call cursor(a:lnum, idx)
                                let lnum = searchpair('<\w', '' , '\S>', 'bW', '', max([a:lnum - b:html_indent_line_limit, 0]))
                                if lnum > 0
                                  return [lnum, 1]
                                endif
                              endif
    1              0.000004   return [a:lnum, 0]

FUNCTION  <SNR>131_InvokeChain()
Called 7 times
Total time:   0.022002
 Self time:   0.000196

count  total (s)   self (s)
    7   0.003516   0.000053     let l:options = ale#engine#ProcessChain(a:buffer, a:linter, a:chain_index, a:input)
    7              0.000020     let l:options.executable = a:executable
                            
    7   0.018446   0.000102     return s:RunJob(l:options)

FUNCTION  airline#themes#get_highlight()
Called 450 times
Total time:   0.080381
 Self time:   0.002380

count  total (s)   self (s)
  450   0.080231   0.002230   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  ale#highlight#RemoveHighlights()
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    4              0.000010     for l:match in getmatches()
    2              0.000007         if l:match.group =~# '^ALE'
                                        call matchdelete(l:match.id)
                                    endif
    2              0.000001     endfor

FUNCTION  <SNR>161_is_modified_and_added()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000004   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  <SNR>284_FreshState()
Called 1 time
Total time:   0.000667
 Self time:   0.000561

count  total (s)   self (s)
                              "{{{
                              " A state is to know ALL relevant details about the
                              " lines 1..a:lnum-1, initial calculating (here!) can be slow, but updating is
                              " fast (incremental).
                              " TODO: this should be split up in detecting the block type and computing the
                              " indent for the block type, so that when we do not know the indent we do
                              " not need to clear the whole state and re-detect the block type again.
                              " State:
                              "	lnum		last indented line == prevnonblank(a:lnum - 1)
                              "	block = 0	a:lnum located within special tag: 0:none, 2:<pre>,
                              "			3:<script>, 4:<style>, 5:<!--, 6:<!--[
                              "	baseindent	use this indent for line a:lnum as a start - kind of
                              "			autoindent (if block==0)
                              "	scripttype = ''	type attribute of a script tag (if block==3)
                              "	blocktagind	indent for current opening (get) and closing (set)
                              "			blocktag (if block!=0)
                              "	blocklnr	lnum of starting blocktag (if block!=0)
                              "	inattr		line {lnum} starts with attributes of a tag
    1              0.000004   let state = {}
    1              0.000007   let state.lnum = prevnonblank(a:lnum - 1)
    1              0.000004   let state.scripttype = ""
    1              0.000003   let state.blocktagind = -1
    1              0.000003   let state.block = 0
    1              0.000003   let state.baseindent = 0
    1              0.000003   let state.blocklnr = 0
    1              0.000003   let state.inattr = 0
                            
    1              0.000003   if state.lnum == 0
                                return state
                              endif
                            
                              " Heuristic:
                              " remember startline state.lnum
                              " look back for <pre, </pre, <script, </script, <style, </style tags
                              " remember stopline
                              " if opening tag found,
                              "	assume a:lnum within block
                              " else
                              "	look back in result range (stopline, startline) for comment
                              "	    \ delimiters (<!--, -->)
                              "	if comment opener found,
                              "	    assume a:lnum within comment
                              "	else
                              "	    assume usual html for a:lnum
                              "	    if a:lnum-1 has a closing comment
                              "		look back to get indent of comment opener
                              " FI
                            
                              " look back for a blocktag
    1              0.000004   let stopline2 = v:lnum + 1
    1              0.000007   if has_key(b:hi_indent, 'block') && b:hi_indent.block > 5
                                let [stopline2, stopcol2] = searchpos('<!--', 'bnW')
                              endif
    1              0.000030   let [stopline, stopcol] = searchpos('\c<\zs\/\=\%(pre\>\|script\>\|style\>\)', "bnW")
    1              0.000004   if stopline > 0 && stopline < stopline2
                                " ugly ... why isn't there searchstr()
                                let tagline = tolower(getline(stopline))
                                let blocktag = matchstr(tagline, '\/\=\%(pre\>\|script\>\|style\>\)', stopcol - 1)
                                if blocktag[0] != "/"
                                  " opening tag found, assume a:lnum within block
                                  let state.block = s:indent_tags[blocktag]
                                  if state.block == 3
                                    let state.scripttype = s:GetScriptType(matchstr(tagline, '\>[^>]*', stopcol))
                                  endif
                                  let state.blocklnr = stopline
                                  " check preceding tags in the line:
                                  call s:CountITags(tagline[: stopcol-2])
                                  let state.blocktagind = indent(stopline) + (s:curind + s:nextrel) * shiftwidth()
                                  return state
                                elseif stopline == state.lnum
                                  " handle special case: previous line (= state.lnum) contains a
                                  " closing blocktag which is preceded by line-noise;
                                  " blocktag == "/..."
                                  let swendtag = match(tagline, '^\s*</') >= 0
                                  if !swendtag
                                    let [bline, bcol] = searchpos('<'.blocktag[1:].'\>', "bnW")
                                    call s:CountITags(tolower(getline(bline)[: bcol-2]))
                                    let state.baseindent = indent(bline) + (s:curind + s:nextrel) * shiftwidth()
                                    return state
                                  endif
                                endif
                              endif
    1              0.000003   if stopline > stopline2
                                let stopline = stopline2
                                let stopcol = stopcol2
                              endif
                            
                              " else look back for comment
    1              0.000074   let [comlnum, comcol, found] = searchpos('\(<!--\[\)\|\(<!--\)\|-->', 'bpnW', stopline)
    1              0.000004   if found == 2 || found == 3
                                " comment opener found, assume a:lnum within comment
                                let state.block = (found == 3 ? 5 : 6)
                                let state.blocklnr = comlnum
                                " check preceding tags in the line:
                                call s:CountITags(tolower(getline(comlnum)[: comcol-2]))
                                if found == 2
                                  let state.baseindent = b:hi_indent.baseindent
                                endif
                                let state.blocktagind = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                return state
                              endif
                            
                              " else within usual HTML
    1              0.000008   let text = tolower(getline(state.lnum))
                            
                              " Check a:lnum-1 for closing comment (we need indent from the opening line).
                              " Not when other tags follow (might be --> inside a string).
    1              0.000007   let comcol = stridx(text, '-->')
    1              0.000005   if comcol >= 0 && match(text, '[<>]', comcol) <= 0
                                call cursor(state.lnum, comcol + 1)
                                let [comlnum, comcol] = searchpos('<!--', 'bW')
                                if comlnum == state.lnum
                                  let text = text[: comcol-2]
                                else
                                  let text = tolower(getline(comlnum)[: comcol-2])
                                endif
                                call s:CountITags(text)
                                let state.baseindent = indent(comlnum) + (s:curind + s:nextrel) * shiftwidth()
                                " TODO check tags that follow "-->"
                                return state
                              endif
                            
                              " Check if the previous line starts with end tag.
    1              0.000015   let swendtag = match(text, '^\s*</') >= 0
                            
                              " If previous line ended in a closing tag, line up with the opening tag.
    1              0.000010   if !swendtag && text =~ '</\w\+\s*>\s*$'
                                call cursor(state.lnum, 99999)
                                normal! F<
                                let start_lnum = HtmlIndent_FindStartTag()
                                if start_lnum > 0
                                  let state.baseindent = indent(start_lnum)
                                  if col('.') > 2
                                    " check for tags before the matching opening tag.
                                    let text = getline(start_lnum)
                                    let swendtag = match(text, '^\s*</') >= 0
                                    call s:CountITags(text[: col('.') - 2])
                                    let state.baseindent += s:nextrel * shiftwidth()
                                    if !swendtag
                                      let state.baseindent += s:curind * shiftwidth()
                                    endif
                                  endif
                                  return state
                                endif
                              endif
                            
                              " Else: no comments. Skip backwards to find the tag we're inside.
    1   0.000074   0.000022   let [state.lnum, found] = HtmlIndent_FindTagStart(state.lnum)
                              " Check if that line starts with end tag.
    1              0.000005   let text = getline(state.lnum)
    1              0.000011   let swendtag = match(text, '^\s*</') >= 0
    1   0.000075   0.000021   call s:CountITags(tolower(text))
    1              0.000010   let state.baseindent = indent(state.lnum) + s:nextrel * shiftwidth()
    1              0.000003   if !swendtag
    1              0.000005     let state.baseindent += s:curind * shiftwidth()
    1              0.000002   endif
    1              0.000002   return state

FUNCTION  <SNR>50_on_bufenter()
Called 1 time
Total time:   0.000078
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000003   if exists('t:gitgutter_didtabenter') && t:gitgutter_didtabenter
                                let t:gitgutter_didtabenter = 0
                                call gitgutter#all(!g:gitgutter_terminal_reports_focus)
                              else
    1   0.000033   0.000006     call gitgutter#init_buffer(bufnr(''))
    1   0.000036   0.000004     call gitgutter#process_buffer(bufnr(''), !g:gitgutter_terminal_reports_focus)
    1              0.000000   endif

FUNCTION  <SNR>90_GetRpcFunction()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004   if a:sync ==# 'urgent'
                                return 'rpcnotify'
                              elseif a:sync
                                return 'remote#define#request'
                              endif
    1              0.000002   return 'remote#define#notify'

FUNCTION  NERDTreeGetGitStatusPrefix()
Called 160 times
Total time:   0.090222
 Self time:   0.012065

count  total (s)   self (s)
  160              0.000536     if localtime() - s:GitStatusCacheTime > s:GitStatusCacheTimeExpiry
    3              0.000016         let s:GitStatusCacheTime = localtime()
    3   0.039700   0.000065         call g:NERDTreeGitStatusRefresh()
    3              0.000003     endif
  160   0.017856   0.000851     let l:pathStr = a:path.str()
  160   0.019169   0.001407     let l:cwd = b:NERDTree.root.path.str() . a:path.Slash()
  160   0.001465   0.000518     if nerdtree#runningWindows()
                                    let l:pathStr = a:path.WinToUnixPath(l:pathStr)
                                    let l:cwd = a:path.WinToUnixPath(l:cwd)
                                endif
  160              0.000890     let l:cwd = substitute(l:cwd, '\~', '\\~', 'g')
  160              0.002871     let l:pathStr = substitute(l:pathStr, l:cwd, '', '')
  160              0.000285     let l:statusKey = ''
  160              0.000235     if a:path.isDirectory
   36              0.000312         let l:statusKey = get(b:NERDTreeCachedGitDirtyDir, fnameescape(l:pathStr . '/'), '')
   36              0.000040     else
  124              0.000598         let l:statusKey = get(b:NERDTreeCachedGitFileStatus, fnameescape(l:pathStr), '')
  124              0.000075     endif
  160   0.003708   0.000899     return s:NERDTreeGetIndicator(l:statusKey)

FUNCTION  <SNR>49_NERDTreeCacheDirtyDir()
Called 51 times
Total time:   0.004371
 Self time:   0.003471

count  total (s)   self (s)
                                " cache dirty dir
   51   0.001370   0.000469     let l:dirtyPath = s:NERDTreeTrimDoubleQuotes(a:pathStr)
   51              0.000268     if l:dirtyPath =~# '\.\./.*'
                                    return
                                endif
   51              0.000597     let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*$', '/', '')
   66              0.001049     while l:dirtyPath =~# '.\+/.*' && has_key(b:NERDTreeCachedGitDirtyDir, fnameescape(l:dirtyPath)) == 0
   15              0.000121         let b:NERDTreeCachedGitDirtyDir[fnameescape(l:dirtyPath)] = 'Dirty'
   15              0.000177         let l:dirtyPath = substitute(l:dirtyPath, '/[^/]*/$', '/', '')
   15              0.000024     endwhile

FUNCTION  <SNR>133_reset_summary()
Called 2 times
Total time:   0.000034
 Self time:   0.000009

count  total (s)   self (s)
    2   0.000033   0.000008   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#highlight#UpdateHighlights()
Called 2 times
Total time:   0.000680
 Self time:   0.000589

count  total (s)   self (s)
    2              0.000009     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    2   0.000043   0.000011     call ale#highlight#RemoveHighlights()
                            
   17              0.000015     for l:item in l:item_list
   15              0.000016         if l:item.type is# 'W'
                                        if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
                                            let l:group = 'ALEWarning'
                                        endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
   15              0.000014             let l:group = 'ALEError'
   15              0.000007         endif
                            
   15              0.000016         let l:line = l:item.lnum
   15              0.000016         let l:col = l:item.col
   15              0.000029         let l:end_line = get(l:item, 'end_lnum', l:line)
   15              0.000027         let l:end_col = get(l:item, 'end_col', l:col)
                            
                                    " Set all of the positions, which are chunked into Lists which
                                    " are as large as will be accepted by matchaddpos.
   15   0.000262   0.000202         call map(   ale#highlight#CreatePositions(l:line, l:col, l:end_line, l:end_col),   'matchaddpos(l:group, v:val)')
   15              0.000012     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    2              0.000002     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call matchaddpos(l:group, [l:item.lnum])
                                        endif
                                    endfor
                                endif

FUNCTION  <SNR>107_ws_refresh()
Called 5 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    5              0.000014   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    3              0.000002     return
                              endif
    2              0.000007   unlet! b:airline_whitespace_check
    2              0.000004   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif
    2              0.000006   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>310_RestoreKeywords()
Called 4 times
Total time:   0.000123
 Self time:   0.000122

count  total (s)   self (s)
    4   0.000122   0.000120 	let &l:iskeyword=s:IsKeywordBak

FUNCTION  <SNR>115_get_accented_line()
Called 3 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
    3              0.000008   if a:self._context.active
    3              0.000008     let contents = []
    3              0.000032     let content_parts = split(a:contents, '__accent')
    6              0.000014     for cpart in content_parts
    3              0.000028       let accent = matchstr(cpart, '_\zs[^#]*\ze')
    3              0.000009       call add(contents, cpart)
    3              0.000003     endfor
    3              0.000016     let line = join(contents, a:group)
    3              0.000030     let line = substitute(line, '__restore__', a:group, 'g')
    3              0.000004   else
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
                              endif
    3              0.000005   return line

FUNCTION  ale#lsp_linter#StartLSP()
Called 7 times
Total time:   0.003853
 Self time:   0.000801

count  total (s)   self (s)
    7              0.000013     let l:command = ''
    7              0.000010     let l:address = ''
    7   0.001036   0.000091     let l:root = ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)
                            
    7              0.000021     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    return {}
                                endif
                            
    7   0.000195   0.000056     let l:init_options = ale#lsp_linter#GetOptions(a:buffer, a:linter)
                            
    7              0.000014     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                                    let l:conn_id = ale#lsp#Register(l:address, l:root, l:init_options)
                                    let l:ready = ale#lsp#ConnectToAddress(l:conn_id, l:address)
                                else
    7   0.002014   0.000047         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    7              0.000399         if empty(l:executable) || !executable(l:executable)
    7              0.000009             return {}
                                    endif
                            
                                    let l:conn_id = ale#lsp#Register(l:executable, l:root, l:init_options)
                            
                                    let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                                    " Format the command, so %e can be formatted into it.
                                    let l:command = ale#command#FormatCommand(a:buffer, l:executable, l:command, 0)[1]
                                    let l:command = ale#job#PrepareCommand(a:buffer, l:command)
                                    let l:ready = ale#lsp#StartProgram(l:conn_id, l:executable, l:command)
                                endif
                            
                                if !l:ready
                                    if g:ale_history_enabled && !empty(l:command)
                                        call ale#history#Add(a:buffer, 'failed', l:conn_id, l:command)
                                    endif
                            
                                    return {}
                                endif
                            
                                " tsserver behaves differently, so tell the LSP API that it is tsserver.
                                if a:linter.lsp is# 'tsserver'
                                    call ale#lsp#MarkConnectionAsTsserver(l:conn_id)
                                endif
                            
                                let l:config = ale#lsp_linter#GetConfig(a:buffer, a:linter)
                                let l:language_id = ale#util#GetFunction(a:linter.language_callback)(a:buffer)
                            
                                let l:details = {   'buffer': a:buffer,   'connection_id': l:conn_id,   'command': l:command,   'project_root': l:root,   'language_id': l:language_id,}
                            
                                call ale#lsp#UpdateConfig(l:conn_id, a:buffer, l:config)
                            
                                if ale#lsp#OpenDocument(l:conn_id, a:buffer, l:language_id)
                                    if g:ale_history_enabled && !empty(l:command)
                                        call ale#history#Add(a:buffer, 'started', l:conn_id, l:command)
                                    endif
                                endif
                            
                                " The change message needs to be sent for tsserver before doing anything.
                                if a:linter.lsp is# 'tsserver'
                                    call ale#lsp#NotifyForChanges(l:conn_id, a:buffer)
                                endif
                            
                                return l:details

FUNCTION  <SNR>284_CountTagsAndState()
Called 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
                              "{{{
                              " Store the result in s:curind and s:nextrel.  Update b:hi_newstate.block.
    1              0.000003   let s:curind = 0  " relative indent steps for current line [unit &sw]:
    1              0.000003   let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
                            
    1              0.000004   let s:block = b:hi_newstate.block
    1              0.000027   let tmp = substitute(a:text, '<\zs/\=\w\+\(-\w\+\)*\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
    1              0.000003   if s:block == 3
                                let b:hi_newstate.scripttype = s:GetScriptType(matchstr(tmp, '\C.*<SCRIPT\>\zs[^>]*'))
                              endif
    1              0.000004   let b:hi_newstate.block = s:block

FUNCTION  <SNR>127_AutoUpdate()
Called 6 times
Total time:   0.001405
 Self time:   0.000659

count  total (s)   self (s)
    6   0.000072   0.000032     call tagbar#debug#log('AutoUpdate called [' . a:fname . ']')
                            
                                " Whether we want to skip actually displaying the tags in Tagbar and only
                                " update the fileinfo
    6              0.000014     let no_display = a:0 > 0 ? a:1 : 0
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    6              0.000010     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call tagbar#debug#log('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
    6              0.000336     let bufnr = bufnr(a:fname)
    6              0.000020     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    6              0.000007     if ftype == 'tagbar'
                                    call tagbar#debug#log('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    6              0.000033     let sftype = get(split(ftype, '\.'), 0, '')
    6   0.000064   0.000034     call tagbar#debug#log("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    6   0.000695   0.000045     if !s:IsValidFile(a:fname, sftype)
    6   0.000045   0.000019         call tagbar#debug#log('Not a valid file, stopping processing')
    6              0.000015         let s:nearby_disabled = 1
    6              0.000004         return
                                endif
                            
                                let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
                                if s:known_files.has(a:fname)
                                    let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
                                    if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call tagbar#debug#log('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
                                    else
                                        call tagbar#debug#log('File data seems up to date [' . a:fname . ']')
                                    endif
                                elseif !s:known_files.has(a:fname)
                                    call tagbar#debug#log('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
                                if no_display
                                    return
                                endif
                            
                                let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
                                if empty(fileinfo)
                                    call tagbar#debug#log('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
                                if bufwinnr(s:TagbarBufName()) != -1 && !s:paused && (s:new_window || updated || (!empty(tagbar#state#get_current_file(0)) && a:fname != tagbar#state#get_current_file(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
                                if !empty(fileinfo)
                                    call tagbar#debug#log('Setting current file [' . a:fname . ']')
                                    call tagbar#state#set_current_file(fileinfo)
                                    let s:nearby_disabled = 0
                                endif
                            
                                call s:HighlightTag(0)
                                call s:SetStatusLine()
                                call tagbar#debug#log('AutoUpdate finished successfully')

FUNCTION  ale#node#Executable()
Called 7 times
Total time:   0.000314
 Self time:   0.000125

count  total (s)   self (s)
    7   0.000095   0.000036     if ale#Has('win32') && a:executable =~? '\.js$'
                                    let l:node = ale#Var(a:buffer, 'windows_node_executable_path')
                            
                                    return ale#Escape(l:node) . ' ' . ale#Escape(a:executable)
                                endif
                            
    7   0.000163   0.000033     return ale#Escape(a:executable)

FUNCTION  <SNR>102_get_hunks()
Called 213 times
Total time:   0.013531
 Self time:   0.005151

count  total (s)   self (s)
  213              0.000846   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
                              endif
  213   0.009639   0.001259   return {b:source_func}()

FUNCTION  <SNR>115_get_transitioned_seperator()
Called 2 times
Total time:   0.005231
 Self time:   0.000144

count  total (s)   self (s)
    2              0.000006   let line = ''
    2   0.002856   0.000034   call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
    2              0.000014   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
                              else
    2   0.002284   0.000019     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
    2              0.000013     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
    2              0.000012     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
    2              0.000007     let line .= '%#'.a:group.'#'
    2              0.000002   endif
    2              0.000004   return line

FUNCTION  260()
Called 4 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    4              0.000004     return '.. (up a dir)'

FUNCTION  <SNR>162_find_current_signs()
Called 1 time
Total time:   0.000775
 Self time:   0.000722

count  total (s)   self (s)
    1              0.000002   let gitgutter_signs = {}  " <line_number (string)>: {'id': <id (number)>, 'name': <name (string)>}
    1              0.000001   let other_signs = []      " [<line_number (number),...]
    1              0.000001   let dummy_sign_placed = 0
                            
    1              0.000002   redir => signs
    1              0.000028     silent execute "sign place buffer=" . a:bufnr
    1              0.000002   redir END
                            
   21              0.000052   for sign_line in filter(split(signs, '\n')[2:], 'v:val =~# "="')
                                " Typical sign line:  line=88 id=1234 name=GitGutterLineAdded
                                " We assume splitting is faster than a regexp.
   20              0.000132     let components  = split(sign_line)
   20              0.000055     let name        = split(components[2], '=')[1]
   20              0.000045     if name =~# 'GitGutterDummy'
                                  let dummy_sign_placed = 1
                                else
   20              0.000062       let line_number = str2nr(split(components[0], '=')[1])
   20              0.000036       if name =~# 'GitGutter'
    9              0.000026         let id = str2nr(split(components[1], '=')[1])
                                    " Remove orphaned signs (signs placed on lines which have been deleted).
                                    " (When a line is deleted its sign lingers.  Subsequent lines' signs'
                                    " line numbers are decremented appropriately.)
    9              0.000016         if has_key(gitgutter_signs, line_number)
                                      execute "sign unplace" gitgutter_signs[line_number].id
                                    endif
    9              0.000030         let gitgutter_signs[line_number] = {'id': id, 'name': name}
    9              0.000004       else
   11              0.000017         call add(other_signs, line_number)
   11              0.000004       endif
   20              0.000008     end
   20              0.000008   endfor
                            
    1   0.000019   0.000006   call gitgutter#utility#setbufvar(a:bufnr, 'dummy_sign', dummy_sign_placed)
    1   0.000032   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'gitgutter_signs', gitgutter_signs)
    1   0.000015   0.000004   call gitgutter#utility#setbufvar(a:bufnr, 'other_signs', other_signs)

FUNCTION  bufferline#get_echo_string()
Called 219 times
Total time:   0.147155
 Self time:   0.011046

count  total (s)   self (s)
                              " check for special cases like help files
  219              0.000618   let current = bufnr('%')
  219              0.000636   if !bufexists(current) || !buflisted(current)
    2              0.000003     return bufname('%')
                              endif
                            
  217   0.137153   0.001044   let names = s:generate_names()
  217              0.000285   let line = ''
 1085              0.001022   for val in names
  868              0.001614     let line .= val[1]
  868              0.000568   endfor
                            
  217              0.001232   let index = match(line, '\V'.g:bufferline_status_info.current)
  217              0.000566   let g:bufferline_status_info.count = len(names)
  217              0.000719   let g:bufferline_status_info.before = strpart(line, 0, index)
  217              0.000948   let g:bufferline_status_info.after = strpart(line, index + len(g:bufferline_status_info.current))
  217              0.000230   return line

FUNCTION  13()
Called 132 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
  132              0.000150     if self.cachedDisplayString ==# ""
                                    call self.cacheDisplayString()
                                endif
                            
  132              0.000113     return self.cachedDisplayString

FUNCTION  <SNR>127_Init()
Called 12 times
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
   12              0.000023     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
   12              0.000016     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
   12              0.000015     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
   12              0.000019     let s:init_done = 1
   12              0.000010     return 1

FUNCTION  ale#history#RememberOutput()
Called 1 time
Total time:   0.000021
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000018   0.000004     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    1              0.000002     let l:obj.output = a:output

FUNCTION  <SNR>125_is_exiting()
Called 48 times
Total time:   0.000427
 Self time:   0.000427

count  total (s)   self (s)
   48              0.000366   return exists('v:exiting') && v:exiting != v:null

FUNCTION  ale#ShouldDoNothing()
Called 11 times
Total time:   0.001041
 Self time:   0.000768

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   11              0.000057     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   11              0.000050     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
   11              0.000042     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   11              0.000016     if l:filetype is# ''
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
   11              0.000051     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
    2              0.000001         return 1
                                endif
                            
                                " Do nothing if running from command mode.
    9              0.000032     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
    9              0.000038     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
    9              0.000012     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
    9   0.000082   0.000047     if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
    9   0.000176   0.000032     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
    9   0.000132   0.000039     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
    9              0.000067     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
    9              0.000007     return 0

FUNCTION  deoplete#util#uniq()
Called 40 times
Total time:   0.004945
 Self time:   0.004945

count  total (s)   self (s)
   40              0.000550   let list = map(copy(a:list), '[v:val, v:val]')
   40              0.000087   let i = 0
   40              0.000081   let seen = {}
  250              0.000501   while i < len(list)
  210              0.000725     let key = string(list[i][1])
  210              0.000481     if has_key(seen, key)
    1              0.000002       call remove(list, i)
    1              0.000000     else
  209              0.000586       let seen[key] = 1
  209              0.000291       let i += 1
  209              0.000137     endif
  210              0.000166   endwhile
   40              0.000316   return map(list, 'v:val[0]')

FUNCTION  airline#extensions#po#apply()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000008   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
                              endif

FUNCTION  20()
Called 968 times
Total time:   0.007738
 Self time:   0.007738

count  total (s)   self (s)
  968              0.001332     if empty(self.pathSegments)
                                    return ''
                                endif
  968              0.001619     let toReturn = self.pathSegments[-1]
  968              0.001038     if a:dirSlash && self.isDirectory
   36              0.000116         let toReturn = toReturn . '/'
   36              0.000034     endif
  968              0.000768     return toReturn

FUNCTION  25()
Called 404 times
Total time:   0.004345
 Self time:   0.001531

count  total (s)   self (s)
  404   0.004248   0.001433     return self.getLastPathComponent(0) =~# '^\.'

FUNCTION  27()
Called 404 times
Total time:   0.029200
 Self time:   0.012048

count  total (s)   self (s)
                                "filter out the user specified paths to ignore
  404   0.001440   0.000996     if a:nerdtree.ui.isIgnoreFilterEnabled()
  808              0.000757         for i in g:NERDTreeIgnore
  404   0.010985   0.001133             if self._ignorePatternMatches(i)
                                            return 1
                                        endif
  404              0.000200         endfor
                            
  404   0.002869   0.001181         for callback in g:NERDTree.PathFilters()
                                        if {callback}({'path': self, 'nerdtree': a:nerdtree})
                                            return 1
                                        endif
                                    endfor
  404              0.000175     endif
                            
                                "dont show hidden files unless instructed to
  404   0.006579   0.001800     if !a:nerdtree.ui.getShowHidden() && self.isUnixHiddenFile()
   48              0.000028         return 1
                                endif
                            
  356   0.001465   0.001077     if a:nerdtree.ui.getShowFiles() ==# 0 && self.isDirectory ==# 0
                                    return 1
                                endif
                            
  356              0.000177     return 0

FUNCTION  28()
Called 404 times
Total time:   0.009852
 Self time:   0.006911

count  total (s)   self (s)
  404              0.000479     let pat = a:pattern
  404              0.000897     if strpart(pat,len(pat)-7) == '[[dir]]'
                                    if !self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-7)
                                elseif strpart(pat,len(pat)-8) == '[[file]]'
                                    if self.isDirectory
                                        return 0
                                    endif
                                    let pat = strpart(pat,0, len(pat)-8)
                                endif
                            
  404   0.004512   0.001571     return self.getLastPathComponent(0) =~# pat

FUNCTION  <SNR>159_on_exit_nvim()
Called 1 time
Total time:   0.002046
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000002   if !a:exit_code
    1   0.002042   0.000013     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    1              0.000001   endif

FUNCTION  airline#util#ignore_buf()
Called 213 times
Total time:   0.004673
 Self time:   0.004673

count  total (s)   self (s)
  213              0.001347   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  'gundo|undotree|vimfiler|tagbar|nerd_tree|startify|!')
  213              0.003153   return match(a:name, pat) > -1

FUNCTION  115()
Called 564 times
Total time:   0.000734
 Self time:   0.000734

count  total (s)   self (s)
  564              0.000566     return self._nerdtree

FUNCTION  34()
Called 515 times
Total time:   0.009081
 Self time:   0.005526

count  total (s)   self (s)
                            
  515   0.005478   0.001923     if nerdtree#runningWindows()
                                    if exists('+shellslash') && &shellslash
                                        return '/'
                                    endif
                            
                                    return '\'
                                endif
                            
  515              0.000428     return '/'

FUNCTION  38()
Called 160 times
Total time:   0.117375
 Self time:   0.001930

count  total (s)   self (s)
  160   0.106682   0.001192     call g:NERDTreePathNotifier.NotifyListeners('refreshFlags', self, a:nerdtree, {})
  160   0.010578   0.000623     call self.cacheDisplayString()

FUNCTION  127()
Called 124 times
Total time:   0.053814
 Self time:   0.000903

count  total (s)   self (s)
  124   0.053763   0.000852     call self.path.refreshFlags(self.getNerdtree())

FUNCTION  129()
Called 4 times
Total time:   0.042637
 Self time:   0.000026

count  total (s)   self (s)
    4   0.042634   0.000023     return self._renderToString(0, 0)

FUNCTION  <SNR>162_remove_signs()
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000003   if a:all_signs && s:supports_star && empty(gitgutter#utility#getbufvar(a:bufnr, 'other_signs'))
                                let dummy_sign_present = gitgutter#utility#getbufvar(a:bufnr, 'dummy_sign')
                                execute "sign unplace * buffer=" . a:bufnr
                                if dummy_sign_present
                                  execute "sign place" s:dummy_sign_id "line=" . 9999 "name=GitGutterDummy buffer=" . a:bufnr
                                endif
                              else
    1              0.000001     for id in a:sign_ids
                                  execute "sign unplace" id
                                endfor
    1              0.000000   endif

FUNCTION  nerdtree#checkForBrowse()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006     if !isdirectory(a:dir)
    1              0.000001         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  40()
Called 359 times
Total time:   0.038008
 Self time:   0.020136

count  total (s)   self (s)
  359              0.000934     let options = a:0 ? a:1 : {}
  359              0.000517     let toReturn = ""
                            
  359              0.000778     if has_key(options, 'format')
    4              0.000007         let format = options['format']
    4              0.000009         if has_key(self, '_strFor' . format)
    4   0.000069   0.000028             exec 'let toReturn = self._strFor' . format . '()'
    4              0.000002         else
                                        throw 'NERDTree.UnknownFormatError: unknown format "'. format .'"'
                                    endif
    4              0.000002     else
  355   0.018192   0.001727         let toReturn = self._str()
  355              0.000270     endif
                            
  359   0.002984   0.001617     if nerdtree#has_opt(options, 'escape')
                                    let toReturn = shellescape(toReturn)
                                endif
                            
  359              0.000723     if has_key(options, 'truncateTo')
    4              0.000006         let limit = options['truncateTo']
    4              0.000013         if strdisplaywidth(toReturn) > limit-1
  132              0.000395             while strdisplaywidth(toReturn) > limit-1 && strchars(toReturn) > 0
  128              0.000371                 let toReturn = substitute(toReturn, '^.', '', '')
  128              0.000072             endwhile
    4              0.000020             if len(split(toReturn, '/')) > 1
    4              0.000023                 let toReturn = '</' . join(split(toReturn, '/')[1:], '/') . '/'
    4              0.000002             else
                                            let toReturn = '<' . toReturn
                                        endif
    4              0.000002         endif
    4              0.000002     endif
                            
  359              0.000455     return toReturn

FUNCTION  41()
Called 4 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    4              0.000018     let toReturn = '/' . join(self.pathSegments, '/')
    4              0.000007     if self.isDirectory && toReturn != '/'
    4              0.000006         let toReturn  = toReturn . '/'
    4              0.000002     endif
    4              0.000004     return toReturn

FUNCTION  <SNR>131_RunLinter()
Called 14 times
Total time:   0.028575
 Self time:   0.000316

count  total (s)   self (s)
   14              0.000045     if !empty(a:linter.lsp)
    7   0.004016   0.000053         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
    7   0.002226   0.000038         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    7   0.000150   0.000043         if ale#engine#IsExecutable(a:buffer, l:executable)
    7   0.022094   0.000091             return s:InvokeChain(a:buffer, l:executable, a:linter, 0, [])
                                    endif
                                endif
                            
                                return 0

FUNCTION  45()
Called 355 times
Total time:   0.016464
 Self time:   0.007873

count  total (s)   self (s)
  355   0.008432   0.001878     let l:separator = s:Path.Slash()
  355              0.000711     let l:leader = l:separator
                            
  355   0.003271   0.001234     if nerdtree#runningWindows()
                                    let l:leader = self.drive . l:separator
                                endif
                            
  355              0.002593     return l:leader . join(self.pathSegments, l:separator)

FUNCTION  ale#lsp_linter#GetOptions()
Called 7 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    7              0.000018     let l:initialization_options = {}
                            
    7              0.000021     if has_key(a:linter, 'initialization_options_callback')
                                    let l:initialization_options = ale#util#GetFunction(a:linter.initialization_options_callback)(a:buffer)
                                elseif has_key(a:linter, 'initialization_options')
                                    let l:initialization_options = a:linter.initialization_options
                                endif
                            
    7              0.000013     return l:initialization_options

FUNCTION  <SNR>125_completion_begin()
Called 36 times
Total time:   0.122373
 Self time:   0.001905

count  total (s)   self (s)
   36   0.010811   0.000243   if s:is_skip(a:event)
                                call deoplete#mapping#_restore_completeopt()
                                let g:deoplete#_context.candidates = []
                                return
                              endif
                            
   36   0.091849   0.000454   let context = deoplete#init#_context(a:event, [])
   36              0.000116   if context['event'] !=# 'Async'
   14   0.000196   0.000088     call deoplete#init#_prev_completion()
   14              0.000013   endif
                            
   36   0.014492   0.000256   if s:check_omnifunc(context)
   10              0.000008     return
                              endif
                            
   26   0.004356   0.000196   call deoplete#util#rpcnotify( 'deoplete_auto_completion_begin', context)

FUNCTION  130()
Called 136 times
Total time:   0.093918
 Self time:   0.089338

count  total (s)   self (s)
  136              0.000144     let output = ""
  136              0.000116     if a:drawText ==# 1
                            
  132              0.000268         let treeParts = repeat('  ', a:depth - 1)
                            
  132              0.000129         if !self.path.isDirectory
  104              0.000160             let treeParts = treeParts . '  '
  104              0.000049         endif
                            
  132   0.012441   0.000469         let line = treeParts . self.displayString()
                            
  132              0.000236         let output = output . line . "\n"
  132              0.000062     endif
                            
                                " if the node is an open dir, draw its children
  136              0.000169     if self.path.isDirectory ==# 1 && self.isOpen ==# 1
                            
   28   0.012966   0.000104         let childNodesToDraw = self.getVisibleChildren()
                            
   28   0.013020   0.000097         if self.isCascadable() && a:depth > 0
                            
                                        let output = output . childNodesToDraw[0]._renderToString(a:depth, 0)
                            
                                    elseif len(childNodesToDraw) > 0
  160              0.000129             for i in childNodesToDraw
  132              0.000477                 let output = output . i._renderToString(a:depth + 1, 1)
  132              0.000071             endfor
   28              0.000013         endif
   28              0.000012     endif
                            
  136              0.000111     return output

FUNCTION  137()
Called 28 times
Total time:   0.009694
 Self time:   0.000951

count  total (s)   self (s)
   28              0.000031     let l:result = ''
                            
                                " Build a label that identifies this TreeDirNode.
   28              0.000026     let l:label = ''
   28   0.008364   0.000092     let l:cascade = self.getCascade()
   56              0.000054     for l:dirNode in l:cascade
   28   0.000226   0.000103         let l:next = l:dirNode.path.displayString()
   28              0.000093         let l:label .= l:label == '' ? l:next : substitute(l:next,'^.','','')
   28              0.000019     endfor
                            
                                " Select the appropriate open/closed status indicator symbol.
   28              0.000037     if l:cascade[-1].isOpen
   24              0.000040         let l:symbol = g:NERDTreeDirArrowCollapsible
   24              0.000012     else
    4              0.000007         let l:symbol = g:NERDTreeDirArrowExpandable
    4              0.000002     endif
                            
   28   0.000455   0.000107     let l:flags = l:cascade[-1].path.flagSet.renderToString()
                            
   28              0.000066     let l:result = l:symbol . ' ' . l:flags . l:label
   28              0.000023     return l:result

FUNCTION  139()
Called 28 times
Total time:   0.008272
 Self time:   0.000125

count  total (s)   self (s)
   28   0.008231   0.000084     if !self.isCascadable()
   28              0.000029         return [self]
                                endif
                            
                                let vc = self.getVisibleChildren()
                                let visChild = vc[0]
                            
                                return [self] + visChild.getCascade()

FUNCTION  gitgutter#diff#parse_hunk()
Called 3 times
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    3              0.000050   let matches = matchlist(a:line, s:hunk_re)
    3              0.000008   if len(matches) > 0
    3              0.000009     let from_line  = str2nr(matches[1])
    3              0.000012     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    3              0.000007     let to_line    = str2nr(matches[3])
    3              0.000011     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    3              0.000010     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  ale#GetLocItemMessage()
Called 15 times
Total time:   0.000579
 Self time:   0.000579

count  total (s)   self (s)
   15              0.000020     let l:msg = a:format_string
   15              0.000023     let l:severity = g:ale_echo_msg_warning_str
   15              0.000028     let l:code = get(a:item, 'code', '')
   15              0.000026     let l:type = get(a:item, 'type', 'E')
   15              0.000029     let l:linter_name = get(a:item, 'linter_name', '')
   15              0.000034     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
   15              0.000013     if l:type is# 'E'
   15              0.000022         let l:severity = g:ale_echo_msg_error_str
   15              0.000010     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
   15              0.000059     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
   15              0.000048     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
   15              0.000127     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
   15              0.000058     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
   15              0.000013     return l:msg

FUNCTION  ale#events#QuitEvent()
Called 2 times
Total time:   0.000128
 Self time:   0.000096

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    2   0.000116   0.000083     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  148()
Called 84 times
Total time:   0.033475
 Self time:   0.003839

count  total (s)   self (s)
   84              0.000090     let toReturn = []
  488              0.000374     for i in self.children
  404   0.031520   0.001885         if i.path.ignore(self.getNerdtree()) ==# 0
  356              0.000534             call add(toReturn, i)
  356              0.000159         endif
  404              0.000204     endfor
   84              0.000058     return toReturn

FUNCTION  gitgutter#diff#process_hunks()
Called 1 time
Total time:   0.000484
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000001   let modified_lines = []
    4              0.000004   for hunk in a:hunks
    3   0.000472   0.000017     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
    3              0.000002   endfor
    1              0.000001   return modified_lines

FUNCTION  ale#engine#InitBufferInfo()
Called 14 times
Total time:   0.000212
 Self time:   0.000212

count  total (s)   self (s)
   14              0.000056     if !has_key(g:ale_buffer_info, a:buffer)
                                    " job_list will hold the list of job IDs
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    " temporary_file_list holds temporary files to be cleaned up
                                    " temporary_directory_list holds temporary directories to be cleaned up
                                    let g:ale_buffer_info[a:buffer] = {   'job_list': [],   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],   'temporary_file_list': [],   'temporary_directory_list': [],}
                            
                                    return 1
                                endif
                            
   14              0.000013     return 0

FUNCTION  <SNR>125_on_complete_done()
Called 10 times
Total time:   0.000238
 Self time:   0.000099

count  total (s)   self (s)
   10              0.000040   if get(v:completed_item, 'word', '') ==# ''
    8              0.000006     return
                              endif
                            
    2              0.000004   let word = v:completed_item.word
    2              0.000005   if !has_key(g:deoplete#_rank, word)
                                let g:deoplete#_rank[word] = 1
                              else
    2              0.000007     let g:deoplete#_rank[word] += 1
    2              0.000001   endif
                            
    2   0.000153   0.000014   call deoplete#handler#_skip_next_completion()

FUNCTION  deoplete#init#_channel_initialized()
Called 27 times
Total time:   0.000142
 Self time:   0.000142

count  total (s)   self (s)
   27              0.000121   return get(g:, 'deoplete#_initialized', v:false)

FUNCTION  deoplete#handler#_skip_next_completion()
Called 2 times
Total time:   0.000139
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000005   if !exists('g:deoplete#_context')
                                return
                              endif
                            
    2   0.000100   0.000009   let input = deoplete#util#get_input('CompleteDone')
    2              0.000004   if input[-1:] !=# '/'
    2              0.000005     let g:deoplete#_context.input = input
    2              0.000001   endif
    2   0.000020   0.000008   call deoplete#init#_prev_completion()

FUNCTION  <SNR>90_GetCommandPrefix()
Called 1 time
Total time:   0.000219
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000217   0.000023   return 'command!'.s:StringifyOpts(a:opts, ['nargs', 'complete', 'range', 'count', 'bang', 'bar', 'register']).' '.a:name

FUNCTION  airline#section#create()
Called 1 time
Total time:   0.000431
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000430   0.000023   return s:create(a:parts, 0)

FUNCTION  150()
Called 56 times
Total time:   0.021070
 Self time:   0.000457

count  total (s)   self (s)
   56              0.000076     if g:NERDTreeCascadeSingleChildDir == 0
                                    return 0
                                endif
                            
   56   0.020792   0.000179     let c = self.getVisibleChildren()
   56              0.000102     return len(c) == 1 && c[0].path.isDirectory

FUNCTION  deoplete#util#get_prev_event()
Called 37 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   37              0.000151   return get(g:deoplete#_context, 'event', '')

FUNCTION  airline#extensions#default#apply()
Called 1 time
Total time:   0.000764
 Self time:   0.000107

count  total (s)   self (s)
    1              0.000005   let winnr = a:context.winnr
    1              0.000004   let active = a:context.active
                            
    1   0.000023   0.000015   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    1   0.000577   0.000019     call s:build_sections(a:builder, a:context, s:layout[0])
    1              0.000002   else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
                              endif
                            
    1   0.000103   0.000019   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    1   0.000016   0.000009   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
                                call s:build_sections(a:builder, a:context, s:layout[1])
                              endif
                            
    1              0.000002   return 1

FUNCTION  <SNR>51_unc_path()
Called 1 time
Total time:   0.000035
 Self time:   0.000006

count  total (s)   self (s)
    1   0.000034   0.000006   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  ale#FileTooLarge()
Called 9 times
Total time:   0.000093
 Self time:   0.000093

count  total (s)   self (s)
    9              0.000046     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
    9              0.000031     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#Has()
Called 7 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    7              0.000054     return get(g:ale_has_override, a:feature, has(a:feature))

FUNCTION  NERDTreeRender()
Called 4 times
Total time:   0.045160
 Self time:   0.000020

count  total (s)   self (s)
    4   0.045156   0.000016     call nerdtree#renderView()

FUNCTION  160()
Called 36 times
Total time:   0.209736
 Self time:   0.047964

count  total (s)   self (s)
   36   0.065156   0.000394     call self.path.refreshFlags(self.getNerdtree())
  192              0.000379     for i in self.children
  156   0.054412   0.000598         call i.refreshFlags()
  156              0.000118     endfor

FUNCTION  airline#highlighter#add_separator()
Called 4 times
Total time:   0.005087
 Self time:   0.000104

count  total (s)   self (s)
    4              0.000041   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
    4   0.005042   0.000059   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>24_dopopd()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000009   if !exists('w:fzf_pushd')
    1              0.000002     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet w:fzf_pushd

FUNCTION  <SNR>131_RemoveProblemsForDisabledLinters()
Called 7 times
Total time:   0.000217
 Self time:   0.000217

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    7              0.000018     let l:name_map = {}
                            
   21              0.000032     for l:linter in a:linters
   14              0.000050         let l:name_map[l:linter.name] = 1
   14              0.000011     endfor
                            
    7              0.000058     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#command#FormatCommand()
Called 7 times
Total time:   0.001212
 Self time:   0.000660

count  total (s)   self (s)
    7              0.000013     let l:temporary_file = ''
    7              0.000014     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    7              0.000061     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    7              0.000031     if !empty(a:executable) && l:command =~# '%e'
                                    let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
                                endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    7              0.000016     if l:command =~# '%s'
    7              0.000097         let l:filename = fnamemodify(bufname(a:buffer), ':p')
    7   0.000177   0.000076         let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
    7              0.000005     endif
                            
    7              0.000018     if l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
                                endif
                            
                                " Finish formatting so %% becomes %.
    7              0.000054     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    7              0.000021     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    7   0.000403   0.000042         let l:temporary_file = s:TemporaryFilename(a:buffer)
    7   0.000136   0.000047         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    7              0.000005     endif
                            
    7              0.000019     return [l:temporary_file, l:command]

FUNCTION  82()
Called 160 times
Total time:   0.001018
 Self time:   0.001018

count  total (s)   self (s)
  160              0.000443     if !exists("g:NERDTreeBookmarks")
                                    let g:NERDTreeBookmarks = []
                                endif
  160              0.000199     return g:NERDTreeBookmarks

FUNCTION  airline#util#wrap()
Called 1949 times
Total time:   0.009293
 Self time:   0.009293

count  total (s)   self (s)
 1949              0.004061   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
 1949              0.001937   return a:text

FUNCTION  gitgutter#debug#log()
Called 2 times
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
    2              0.000002   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
                              endif

FUNCTION  ale#events#ClockMilliseconds()
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000028     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  xolox#misc#cursorhold#autocmd()
Called 5 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    5              0.000015   for handler in g:xolox#misc#cursorhold#handlers
                                let function = handler['function']
                                let last_run = get(handler, 'last_run', 0)
                                let interval = get(handler, 'interval', 4)
                                call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
                                let time_until_next_run = (last_run + interval) - localtime()
                                if time_until_next_run > 0
                                  call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
                                else
                                  call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
                                  call call(function, get(handler, 'arguments', []))
                                  let handler['last_run'] = localtime()
                                endif
                              endfor

FUNCTION  airline#util#getwinvar()
Called 8 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    8              0.000054     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  <SNR>183_GroupLoclistItems()
Called 1 time
Total time:   0.000149
 Self time:   0.000149

count  total (s)   self (s)
    1              0.000001     let l:grouped_items = []
    1              0.000001     let l:last_lnum = -1
                            
   16              0.000010     for l:obj in a:loclist
   15              0.000013         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
   15              0.000014         if l:obj.lnum != l:last_lnum
   10              0.000013             call add(l:grouped_items, [])
   10              0.000004         endif
                            
   15              0.000024         call add(l:grouped_items[-1], l:obj)
   15              0.000017         let l:last_lnum = l:obj.lnum
   15              0.000007     endfor
                            
    1              0.000001     return l:grouped_items

FUNCTION  <SNR>135_FindItemAtCursor()
Called 1 time
Total time:   0.000042
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000005     let l:info = get(g:ale_buffer_info, a:buffer, {})
    1              0.000005     let l:loclist = get(l:info, 'loclist', [])
    1              0.000003     let l:pos = getcurpos()
    1   0.000022   0.000011     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    1              0.000003     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    1              0.000002     return [l:info, l:loc]

FUNCTION  <SNR>125_completion_timer_stop()
Called 23 times
Total time:   0.000342
 Self time:   0.000342

count  total (s)   self (s)
   23              0.000076   if !exists('s:completion_timer')
                                return
                              endif
                            
   23              0.000088   call timer_stop(s:completion_timer)
   23              0.000063   unlet s:completion_timer

FUNCTION  <SNR>184_FixList()
Called 1 time
Total time:   0.000814
 Self time:   0.000226

count  total (s)   self (s)
    1   0.000015   0.000005     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    1              0.000001     let l:new_list = []
                            
   16              0.000013     for l:item in a:list
   15              0.000043         let l:fixed_item = copy(l:item)
                            
   15   0.000645   0.000066         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
   15              0.000015         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
   15              0.000024         call add(l:new_list, l:fixed_item)
   15              0.000007     endfor
                            
    1              0.000001     return l:new_list

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 10 times
Total time:   0.006695
 Self time:   0.000658

count  total (s)   self (s)
   10              0.000080   if getbufvar(a:bufnr, '&modified')
    5              0.000140     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    5              0.000009   else
    5              0.000080     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    5              0.000006   endif
                            
   10              0.000037   if !empty(colors)
   10   0.006193   0.000156     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   10              0.000013   endif

FUNCTION  <SNR>161_process_modified_and_removed()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000001   let offset = 0
    2              0.000002   while offset < a:to_count
    1              0.000002     let line_number = a:to_line + offset
    1              0.000002     call add(a:modifications, [line_number, 'modified'])
    1              0.000001     let offset += 1
    1              0.000000   endwhile
    1              0.000003   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  gitgutter#hunk#increment_lines_added()
Called 2 times
Total time:   0.000069
 Self time:   0.000020

count  total (s)   self (s)
    2   0.000035   0.000007   let summary = gitgutter#hunk#summary(a:bufnr)
    2              0.000003   let summary[0] += a:count
    2   0.000029   0.000008   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>53_init()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000003   if s:airline_initialized
    1              0.000001     return
                              endif
                              let s:airline_initialized = 1
                            
                              call airline#extensions#load()
                              call airline#init#sections()
                            
                              let s:theme_in_vimrc = exists('g:airline_theme')
                              if s:theme_in_vimrc
                                try
                                  let palette = g:airline#themes#{g:airline_theme}#palette
                                catch
                                  echom 'Could not resolve airline theme "' . g:airline_theme . '". Themes have been migrated to github.com/vim-airline/vim-airline-themes.'
                                  let g:airline_theme = 'dark'
                                endtry
                                silent call airline#switch_theme(g:airline_theme)
                              else
                                let g:airline_theme = 'dark'
                                silent call s:on_colorscheme_changed()
                              endif
                            
                              call airline#util#doautocmd('AirlineAfterInit')

FUNCTION  <SNR>118_has_fresh_changes()
Called 4 times
Total time:   0.000078
 Self time:   0.000028

count  total (s)   self (s)
    4   0.000075   0.000026   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  nerdtree#runningWindows()
Called 1030 times
Total time:   0.006538
 Self time:   0.006538

count  total (s)   self (s)
 1030              0.006130     return has("win16") || has("win32") || has("win64")

FUNCTION  <SNR>127_do_delayed_update()
Called 5 times
Total time:   0.000219
 Self time:   0.000098

count  total (s)   self (s)
    5   0.000147   0.000026     let curfile = tagbar#state#get_current_file(0)
    5              0.000007     if empty(curfile)
                                    let curfname = ''
                                else
    5              0.000010         let curfname = curfile.fpath
    5              0.000002     endif
                            
    5              0.000011     while !empty(s:delayed_update_files)
                                    let fname = remove(s:delayed_update_files, 0)
                                    let no_display = curfname !=# fname
                                    call s:AutoUpdate(fname, 1, no_display)
                                endwhile

FUNCTION  FugitiveHead()
Called 213 times
Total time:   0.016460
 Self time:   0.002990

count  total (s)   self (s)
  213   0.002087   0.001101   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
  213              0.000344   if empty(dir)
                                return ''
                              endif
  213   0.013593   0.001108   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  111()
Called 104 times
Total time:   0.002278
 Self time:   0.000588

count  total (s)   self (s)
  104   0.002246   0.000556     return self.path.flagSet.renderToString() . self.path.displayString()

FUNCTION  airline#highlighter#highlight()
Called 10 times
Total time:   0.463760
 Self time:   0.041846

count  total (s)   self (s)
   10              0.000053   let bufnr = a:0 ? a:1 : ''
   10              0.000077   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   10              0.000186   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   10              0.000052   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   27              0.000057   for mode in mapped
   17              0.000147     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   13              0.000176       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  336              0.000889       for kvp in items(dict)
  323              0.000748         let mode_colors = kvp[1]
  323              0.000573         let name = kvp[0]
  323              0.000902         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
  323   0.101107   0.002145         call airline#highlighter#exec(name.suffix, mode_colors)
                            
  969              0.001925         for accent in keys(s:accents)
  646              0.001667           if !has_key(p.accents, accent)
                                        continue
                                      endif
  646              0.002142           let colors = copy(mode_colors)
  646              0.001561           if p.accents[accent][0] != ''
  323              0.000875             let colors[0] = p.accents[accent][0]
  323              0.000190           endif
  646              0.001211           if p.accents[accent][2] != ''
  323              0.000702             let colors[2] = p.accents[accent][2]
  323              0.000164           endif
  646              0.001074           if len(colors) >= 5
  646              0.002047             let colors[4] = get(p.accents[accent], 4, '')
  646              0.000392           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
  646   0.193978   0.004822           call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  646              0.000563         endfor
  323              0.000254       endfor
                            
                                  " TODO: optimize this
  234              0.000395       for sep in items(s:separators)
  221   0.135418   0.001622         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  221              0.000152       endfor
   13              0.000006     endif
   17              0.000010   endfor

FUNCTION  NERDTreeGitStatusRefreshListener()
Called 160 times
Total time:   0.096782
 Self time:   0.003948

count  total (s)   self (s)
  160              0.000447     if !exists('b:NOT_A_GIT_REPOSITORY')
                                    call g:NERDTreeGitStatusRefresh()
                                endif
  160              0.000313     let l:path = a:event.subject
  160   0.091061   0.000839     let l:flag = g:NERDTreeGetGitStatusPrefix(l:path)
  160   0.001674   0.000799     call l:path.flagSet.clearFlags('git')
  160              0.000220     if l:flag !=# ''
   84   0.002173   0.000437         call l:path.flagSet.addFlag('git', l:flag)
   84              0.000055     endif

FUNCTION  airline#parts#ffenc()
Called 213 times
Total time:   0.006447
 Self time:   0.006447

count  total (s)   self (s)
  213              0.000825   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  213              0.000496   let bomb     = &l:bomb ? '[BOM]' : ''
  213              0.002255   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  213              0.001361   if expected is# &fenc.bomb.ff
                                return ''
                              else
  213              0.000953     return &fenc.bomb.ff
                              endif

FUNCTION  deoplete#util#vimoption2python()
Called 33 times
Total time:   0.010117
 Self time:   0.000246

count  total (s)   self (s)
   33   0.010101   0.000230   return '[\w' . s:vimoption2python(a:option) . ']'

FUNCTION  gitgutter#utility#shellescape()
Called 7 times
Total time:   0.000152
 Self time:   0.000146

count  total (s)   self (s)
    7              0.000112   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
    6              0.000008     return a:arg
                              elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
                              else
    1              0.000009     return shellescape(a:arg)
                              endif

FUNCTION  tagbar#debug#log()
Called 30 times
Total time:   0.000152
 Self time:   0.000152

count  total (s)   self (s)
   30              0.000028     if s:debug_enabled
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  <SNR>131_StopCurrentJobs()
Called 7 times
Total time:   0.001033
 Self time:   0.000629

count  total (s)   self (s)
    7              0.000028     let l:info = get(g:ale_buffer_info, a:buffer, {})
    7              0.000013     let l:new_job_list = []
    7              0.000015     let l:new_active_linter_list = []
                            
   13              0.000038     for l:job_id in get(l:info, 'job_list', [])
    6              0.000027         let l:job_info = get(s:job_info_map, l:job_id, {})
                            
    6              0.000012         if !empty(l:job_info)
    6              0.000019             if a:include_lint_file_jobs || !l:job_info.linter.lint_file
    6   0.000443   0.000039                 call ale#job#Stop(l:job_id)
    6              0.000033                 call remove(s:job_info_map, l:job_id)
    6              0.000007             else
                                            call add(l:new_job_list, l:job_id)
                                            " Linters with jobs still running are still active.
                                            call add(l:new_active_linter_list, l:job_info.linter.name)
                                        endif
    6              0.000006         endif
    6              0.000007     endfor
                            
                                " Remove duplicates from the active linter list.
    7              0.000033     call uniq(sort(l:new_active_linter_list))
                            
                                " Update the List, so it includes only the jobs we still need.
    7              0.000040     let l:info.job_list = l:new_job_list
                                " Update the active linter list, clearing out anything not running.
    7              0.000033     let l:info.active_linter_list = l:new_active_linter_list

FUNCTION  <SNR>161_is_modified()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000004   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  tagbar#currenttag()
Called 12 times
Total time:   0.000880
 Self time:   0.000561

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   12              0.000032     let s:statusline_in_use = 1
                            
   12              0.000014     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   12              0.000076         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   12              0.000031         let fullpath  = a:1 =~# 'f'
   12              0.000026         let prototype = a:1 =~# 'p'
   12              0.000008     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   12   0.000338   0.000058     if !s:Init(1)
                                    return a:default
                                endif
                            
   12   0.000105   0.000065     let tag = s:GetNearbyTag(0, 1)
                            
   12              0.000022     if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
   12              0.000015         return a:default
                                endif

FUNCTION  <SNR>284_CountITags()
Called 1 time
Total time:   0.000054
 Self time:   0.000054

count  total (s)   self (s)
                              "{{{
                              " Store the result in s:curind and s:nextrel.
    1              0.000005   let s:curind = 0  " relative indent steps for current line [unit &sw]:
    1              0.000003   let s:nextrel = 0  " relative indent steps for next line [unit &sw]:
    1              0.000003   let s:block = 0		" assume starting outside of a block
    1              0.000005   let s:countonly = 1	" don't change state
    1              0.000030   call substitute(a:text, '<\zs/\=\w\+\(-\w\+\)*\>\|<!--\[\|\[endif\]-->\|<!--\|-->', '\=s:CheckTag(submatch(0))', 'g')
    1              0.000003   let s:countonly = 0

FUNCTION  deoplete#handler#_do_complete()
Called 26 times
Total time:   0.001140
 Self time:   0.000990

count  total (s)   self (s)
   26              0.000104   let context = g:deoplete#_context
   26              0.000110   let event = get(context, 'event', '')
   26              0.000111   let modes = (event ==# 'InsertEnter') ? ['n', 'i'] : ['i']
   26   0.000383   0.000234   if s:is_exiting() || index(modes, mode()) < 0
                                call s:completion_timer_stop()
                                return
                              endif
                            
   26              0.000172   if empty(get(context, 'candidates', [])) || deoplete#util#get_input(context.event) !=# context.input
   26              0.000026     return
                              endif
                            
                              let prev = g:deoplete#_prev_completion
                              let prev.event = context.event
                              let prev.input = context.input
                              let prev.candidates = context.candidates
                            
                              if context.event ==# 'Manual'
                                let context.event = ''
                              elseif !exists('g:deoplete#_saved_completeopt')
                                call deoplete#mapping#_set_completeopt()
                              endif
                            
                              let complete_method = deoplete#custom#_get_option('complete_method')
                              if complete_method ==# 'complete'
                                call feedkeys("\<Plug>_", 'i')
                              elseif complete_method ==# 'completefunc'
                                let &l:completefunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-u>", 'in')
                              elseif complete_method ==# 'omnifunc'
                                let &l:omnifunc = 'deoplete#mapping#_completefunc'
                                call feedkeys("\<C-x>\<C-o>", 'in')
                              endif

FUNCTION  deoplete#handler#_async_timer_start()
Called 17 times
Total time:   0.002507
 Self time:   0.001271

count  total (s)   self (s)
   17              0.000187   if exists('s:async_timer')
   12   0.000293   0.000101     call deoplete#handler#_async_timer_stop()
   12              0.000012   endif
                            
   17   0.001314   0.000270   let delay = deoplete#custom#_get_option('auto_refresh_delay')
   17              0.000046   if delay <= 0
                                return
                              endif
                            
   17              0.000136   let s:async_timer = { 'event': 'Async', 'changedtick': b:changedtick }
   17              0.000342   let s:async_timer.id = timer_start( max([20, delay]), function('s:completion_async'), {'repeat': -1})

FUNCTION  gitgutter#sign#update_signs()
Called 1 time
Total time:   0.001185
 Self time:   0.000053

count  total (s)   self (s)
    1   0.000782   0.000007   call s:find_current_signs(a:bufnr)
                            
    1              0.000009   let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
    1   0.000104   0.000011   let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
    1              0.000002   let flicker_possible = s:remove_all_old_signs && !empty(a:modified_lines)
    1              0.000001   if flicker_possible
                                call s:add_dummy_sign(a:bufnr)
                              endif
                            
    1   0.000020   0.000007   call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
    1   0.000258   0.000008   call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)
                            
    1              0.000001   if flicker_possible
                                call gitgutter#sign#remove_dummy_sign(a:bufnr, 0)
                              endif

FUNCTION  <SNR>104_update_branch()
Called 213 times
Total time:   0.043685
 Self time:   0.009764

count  total (s)   self (s)
  639              0.001239   for vcs in keys(s:vcs_config)
  426   0.036999   0.003078     call {s:vcs_config[vcs].update_branch}()
  426              0.001490     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
  426              0.000327   endfor

FUNCTION  ale#util#BinarySearch()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     let l:min = 0
    1              0.000003     let l:max = len(a:loclist) - 1
                            
    1              0.000001     while 1
    1              0.000002         if l:max < l:min
    1              0.000001             return -1
                                    endif
                            
                                    let l:mid = (l:min + l:max) / 2
                                    let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
                                    if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
                                        let l:min = l:mid + 1
                                    elseif l:item.lnum > a:line
                                        let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
                                    endif
                                endwhile

FUNCTION  airline#parts#readonly()
Called 245 times
Total time:   0.008559
 Self time:   0.003886

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  245   0.006450   0.001778   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
   32              0.000040     return ''
                              endif
  213              0.000526   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
  213              0.000375     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
Called 213 times
Total time:   0.012485
 Self time:   0.012485

count  total (s)   self (s)
  213              0.000585   let dir = a:0 > 1 ? a:2 : get(b:, 'git_dir', '')
  213              0.002847   if empty(dir) || !filereadable(dir . '/HEAD')
                                return ''
                              endif
  213              0.003574   let head = readfile(dir . '/HEAD')[0]
  213              0.001674   if head =~# '^ref: '
  213              0.003155     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>125_is_skip()
Called 36 times
Total time:   0.010569
 Self time:   0.001313

count  total (s)   self (s)
   36   0.008154   0.000275   if s:is_skip_text(a:event)
                                return 1
                              endif
                            
   36   0.001727   0.000350   let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
   36              0.000388   if &paste || (a:event !=# 'Manual' && a:event !=# 'Async' && !auto_complete) || (&l:completefunc !=# '' && &l:buftype =~# 'nofile') || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                return 1
                              endif
                            
   36              0.000037   return 0

FUNCTION  <SNR>106_ale_refresh()
Called 13 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
   13              0.000073   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh'
                              endif

FUNCTION  ale#util#GetItemPriority()
Called 15 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
   15              0.000015     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
   15              0.000012     if a:item.type is# 'W'
                                    if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
                                    return g:ale#util#warning_priority
                                endif
                            
   15              0.000023     if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
   15              0.000014     return g:ale#util#error_priority

FUNCTION  nerdtree#has_opt()
Called 359 times
Total time:   0.001366
 Self time:   0.001366

count  total (s)   self (s)
  359              0.001235     return has_key(a:options, a:name) && a:options[a:name] == 1

FUNCTION  airline#util#doautocmd()
Called 10 times
Total time:   0.000491
 Self time:   0.000202

count  total (s)   self (s)
   10   0.000485   0.000196   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  NERDTreeGitStatusRefresh()
Called 3 times
Total time:   0.039634
 Self time:   0.033154

count  total (s)   self (s)
    3              0.000046     let b:NERDTreeCachedGitFileStatus = {}
    3              0.000024     let b:NERDTreeCachedGitDirtyDir   = {}
    3              0.000014     let b:NOT_A_GIT_REPOSITORY        = 1
                            
    3   0.000858   0.000125     let l:root = fnamemodify(b:NERDTree.root.path.str(), ":p:S")
    3              0.000014     let l:gitcmd = 'git -c color.status=false status -s'
    3              0.000010     if g:NERDTreeShowIgnoredStatus
                                    let l:gitcmd = l:gitcmd . ' --ignored'
                                endif
    3              0.000017     if exists('g:NERDTreeGitStatusIgnoreSubmodules')
                                    let l:gitcmd = l:gitcmd . ' --ignore-submodules'
                                    if g:NERDTreeGitStatusIgnoreSubmodules ==# 'all' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'dirty' || g:NERDTreeGitStatusIgnoreSubmodules ==# 'untracked'
                                        let l:gitcmd = l:gitcmd . '=' . g:NERDTreeGitStatusIgnoreSubmodules
                                    endif
                                endif
    3              0.026758     let l:statusesStr = system(l:gitcmd . ' ' . l:root)
    3              0.000243     let l:statusesSplit = split(l:statusesStr, '\n')
    3              0.000063     if l:statusesSplit != [] && l:statusesSplit[0] =~# 'fatal:.*'
                                    let l:statusesSplit = []
                                    return
                                endif
    3              0.000021     let b:NOT_A_GIT_REPOSITORY = 0
                            
   54              0.000151     for l:statusLine in l:statusesSplit
                                    " cache git status of files
   51              0.000610         let l:pathStr = substitute(l:statusLine, '...', '', '')
   51              0.000471         let l:pathSplit = split(l:pathStr, ' -> ')
   51              0.000184         if len(l:pathSplit) == 2
                                        call s:NERDTreeCacheDirtyDir(l:pathSplit[0])
                                        let l:pathStr = l:pathSplit[1]
                                    else
   51              0.000194             let l:pathStr = l:pathSplit[0]
   51              0.000064         endif
   51   0.001456   0.000545         let l:pathStr = s:NERDTreeTrimDoubleQuotes(l:pathStr)
   51              0.000307         if l:pathStr =~# '\.\./.*'
                                        continue
                                    endif
   51   0.001069   0.000603         let l:statusKey = s:NERDTreeGetFileGitStatusKey(l:statusLine[0], l:statusLine[1])
   51              0.000462         let b:NERDTreeCachedGitFileStatus[fnameescape(l:pathStr)] = l:statusKey
                            
   51              0.000136         if l:statusKey == 'Ignored'
                                        if isdirectory(l:pathStr)
                                            let b:NERDTreeCachedGitDirtyDir[fnameescape(l:pathStr)] = l:statusKey
                                        endif
                                    else
   51   0.004804   0.000432             call s:NERDTreeCacheDirtyDir(l:pathStr)
   51              0.000061         endif
   51              0.000069     endfor

FUNCTION  deoplete#mapping#_restore_completeopt()
Called 10 times
Total time:   0.000262
 Self time:   0.000235

count  total (s)   self (s)
   10              0.000089   if exists('g:deoplete#_saved_completeopt')
    4   0.000090   0.000064     let &completeopt = g:deoplete#_saved_completeopt
    4              0.000017     unlet g:deoplete#_saved_completeopt
    4              0.000006   endif

FUNCTION  nerdtree#exec()
Called 4 times
Total time:   0.000385
 Self time:   0.000385

count  total (s)   self (s)
    4              0.000084     let old_ei = &ei
    4              0.000104     set ei=BufEnter,BufLeave,VimEnter
    4              0.000125     exec a:cmd
    4              0.000063     let &ei = old_ei

FUNCTION  ale#linter#GetCommand()
Called 7 times
Total time:   0.002926
 Self time:   0.000088

count  total (s)   self (s)
    7   0.002921   0.000083     return has_key(a:linter, 'command_callback')   ? ale#util#GetFunction(a:linter.command_callback)(a:buffer)   : a:linter.command

FUNCTION  <SNR>136_get()
Called 5 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    5              0.000016     if !exists('t:tagbar_state')
                                    let t:tagbar_state = s:State.New()
                                endif
                            
    5              0.000005     return t:tagbar_state

FUNCTION  xmlcomplete#GetLastOpenTag()
Called 2 times
Total time:   0.001470
 Self time:   0.000748

count  total (s)   self (s)
    2              0.000005 	let linenum=line('.')
    2              0.000005 	let lineend=col('.') - 1 " start: cursor position
    2              0.000003 	let first=1              " flag for first line searched
    2              0.000004 	let b:TagStack=''        " main stack of tags
    2   0.000037   0.000016 	let startInComment=s:InComment()
                            
    2              0.000005 	if exists("b:xml_namespace")
                            		if b:xml_namespace == 'DEFAULT'
                            			let tagpat='</\=\(\k\|[.:-]\)\+\|/>'
                            		else
                            			let tagpat='</\='.b:xml_namespace.':\(\k\|[.-]\)\+\|/>'
                            		endif
                            	else
    2              0.000004 		let tagpat='</\=\(\k\|[.:-]\)\+\|/>'
    2              0.000001 	endif
    6              0.000009 	while (linenum>0)
    6              0.000016 		let line=getline(linenum)
    6              0.000007 		if first
    2              0.000006 			let line=strpart(line,0,lineend)
    2              0.000001 		else
    4              0.000011 			let lineend=strlen(line)
    4              0.000003 		endif
    6              0.000012 		let b:lineTagStack=''
    6              0.000008 		let mpos=0
    6              0.000009 		let b:TagCol=0
   14              0.000019 		while (mpos > -1)
    8              0.000071 			let mpos=matchend(line,tagpat)
    8              0.000010 			if mpos > -1
    2              0.000004 				let b:TagCol=b:TagCol+mpos
    2              0.000014 				let tag=matchstr(line,tagpat)
                            
    2   0.000176   0.000020 				if exists('b:closetag_disable_synID') || startInComment==s:InCommentAt(linenum, b:TagCol)
    2              0.000006 					let b:TagLine=linenum
    2   0.000071   0.000023 					call s:Push(matchstr(tag,'[^<>]\+'),'b:lineTagStack')
    2              0.000001 				endif
    2              0.000004 				let lineend=lineend-mpos
    2              0.000006 				let line=strpart(line,mpos,lineend)
    2              0.000001 			endif
    8              0.000007 		endwhile
    6   0.000102   0.000031 		while (!s:EmptystackP('b:lineTagStack'))
    2   0.000270   0.000012 			let tag=s:Pop('b:lineTagStack')
    2              0.000007 			if match(tag, '^/') == 0		"found end tag
                            				call s:Push(tag,'b:TagStack')
                            			elseif s:EmptystackP('b:TagStack') && !s:Instack(tag, a:unaryTagsStack)	"found unclosed tag
    2              0.000003 				return tag
                            			else
                            				let endtag=s:Peekstack('b:TagStack')
                            				if endtag == '/'.tag || endtag == '/'
                            					call s:Pop('b:TagStack')	"found a open/close tag pair
                            				elseif !s:Instack(tag, a:unaryTagsStack) "we have a mismatch error
                            					return ''
                            				endif
                            			endif
                            		endwhile
    7              0.000015 		let linenum=linenum-1 | let first=0
    4              0.000003 	endwhile
                            return ''

FUNCTION  <SNR>116_add_section()
Called 3 times
Total time:   0.000457
 Self time:   0.000189

count  total (s)   self (s)
    3              0.000031     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
    3              0.000028     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
                                endif
    3              0.000006     if condition
                                  call a:builder.add_raw('%(')
                                endif
    3   0.000335   0.000067     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
    3              0.000007     if condition
                                  call a:builder.add_raw('%)')
                                endif

FUNCTION  airline#highlighter#exec()
Called 1204 times
Total time:   0.345775
 Self time:   0.077249

count  total (s)   self (s)
 1204              0.001795   if pumvisible()
                                return
                              endif
 1204              0.001823   let colors = a:colors
 1204              0.001241   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
 1204   0.209569   0.005825   let old_hi = airline#highlighter#get_highlight(a:group)
 1204              0.002174   if len(colors) == 4
  225              0.000408     call add(colors, '')
  225              0.000098   endif
 1204              0.001644   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
                              else
 1204              0.006931     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
 1204              0.000725   endif
 1204   0.035582   0.005266   let colors = s:CheckDefined(colors)
 1204   0.029773   0.005540   if old_hi != new_hi || !s:hl_group_exists(a:group)
  267   0.016788   0.006556     let cmd = printf('hi %s %s %s %s %s %s %s %s', a:group, s:Get(colors, 0, 'guifg='), s:Get(colors, 1, 'guibg='), s:Get(colors, 2, 'ctermfg='), s:Get(colors, 3, 'ctermbg='), s:Get(colors, 4, 'gui='), s:Get(colors, 4, 'cterm='), s:Get(colors, 4, 'term='))
  267              0.004897     exe cmd
  267              0.000964     if has_key(s:hl_groups, a:group)
  267              0.000807       let s:hl_groups[a:group] = colors
  267              0.000189     endif
  267              0.000149   endif

FUNCTION  ale#util#LocItemCompare()
Called 28 times
Total time:   0.000368
 Self time:   0.000368

count  total (s)   self (s)
   28              0.000028     if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
   28              0.000026     if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
   28              0.000022     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
   28              0.000027     if a:left.lnum < a:right.lnum
   19              0.000010         return -1
                                endif
                            
    9              0.000009     if a:left.lnum > a:right.lnum
                                    return 1
                                endif
                            
    9              0.000009     if a:left.col < a:right.col
    9              0.000005         return -1
                                endif
                            
                                if a:left.col > a:right.col
                                    return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  ale#highlight#CreatePositions()
Called 15 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
   15              0.000017     if a:line >= a:end_line
                                    " For single lines, just return the one position.
   15              0.000031         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  remote#define#CommandOnChannel()
Called 1 time
Total time:   0.000449
 Self time:   0.000191

count  total (s)   self (s)
    1              0.000009   let rpcargs = [a:channel, '"'.a:method.'"']
    1              0.000004   if has_key(a:opts, 'nargs')
                                " -nargs, pass arguments in a list
                                call add(rpcargs, '[<f-args>]')
                              endif
                            
    1              0.000003   if has_key(a:opts, 'range')
                                if a:opts.range == '' || a:opts.range == '%'
                                  " -range or -range=%, pass the line range in a list
                                  call add(rpcargs, '[<line1>, <line2>]')
                                elseif matchstr(a:opts.range, '\d') != ''
                                  " -range=N, pass the count
                                  call add(rpcargs, '<count>')
                                endif
                              elseif has_key(a:opts, 'count')
                                " count
                                call add(rpcargs, '<count>')
                              endif
                            
    1              0.000004   if has_key(a:opts, 'bang')
                                " bang
                                call add(rpcargs, '<q-bang> == "!"')
                              endif
                            
    1              0.000004   if has_key(a:opts, 'register')
                                " register
                                call add(rpcargs, '<q-reg>')
                              endif
                            
    1   0.000044   0.000020   call s:AddEval(rpcargs, a:opts)
    1   0.000327   0.000092   exe s:GetCommandPrefix(a:name, a:opts) . ' call '.s:GetRpcFunction(a:sync).'('.join(rpcargs, ', ').')'

FUNCTION  nerdtree#renderView()
Called 4 times
Total time:   0.045140
 Self time:   0.000020

count  total (s)   self (s)
    4   0.045137   0.000017     call b:NERDTree.render()

FUNCTION  ale#statusline#Update()
Called 1 time
Total time:   0.000220
 Self time:   0.000214

count  total (s)   self (s)
    1              0.000004     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
                                    return
                                endif
                            
    1              0.000013     let l:loclist = filter(copy(a:loclist), 'v:val.bufnr == a:buffer')
    1   0.000012   0.000006     let l:count = s:CreateCountDict()
    1              0.000002     let l:count.total = len(l:loclist)
                            
   16              0.000011     for l:entry in l:loclist
   15              0.000014         if l:entry.type is# 'W'
                                        if get(l:entry, 'sub_type', '') is# 'style'
                                            let l:count.style_warning += 1
                                        else
                                            let l:count.warning += 1
                                        endif
                                    elseif l:entry.type is# 'I'
                                        let l:count.info += 1
                                    elseif get(l:entry, 'sub_type', '') is# 'style'
                                        let l:count.style_error += 1
                                    else
   15              0.000013             let l:count.error += 1
   15              0.000006         endif
   15              0.000007     endfor
                            
                                " Set keys for backwards compatibility.
    1              0.000002     let l:count[0] = l:count.error + l:count.style_error
    1              0.000002     let l:count[1] = l:count.total - l:count[0]
                            
    1              0.000005     let g:ale_buffer_info[a:buffer].count = l:count

FUNCTION  airline#highlighter#add_accent()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000009   let s:accents[a:accent] = 1

FUNCTION  gitgutter#utility#windows()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return has('win64') || has('win32') || has('win16')

FUNCTION  <SNR>112_CheckDefined()
Called 1204 times
Total time:   0.030316
 Self time:   0.030316

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
 1204              0.003347   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
 1204              0.003671   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
 2538              0.003678   for val in a:colors
 2538              0.004737     if !empty(val) && val !=# 'NONE'
 1204              0.001101       return a:colors
                                endif
 1334              0.000834   endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  deoplete#init#_prev_completion()
Called 16 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
   16              0.000108   let g:deoplete#_prev_completion = { 'event': '', 'input': '', 'candidates': [], }

FUNCTION  gitgutter#hunk#summary()
Called 218 times
Total time:   0.003870
 Self time:   0.001600

count  total (s)   self (s)
  218   0.003756   0.001486   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>81_UpdateLastColumn()
Called 2 times
Total time:   0.000497
 Self time:   0.000307

count  total (s)   self (s)
                              " Function to save the current column and buffer and window numbers,
    2              0.000010   let DebugF = 'UpdateColumnList'
    2   0.000084   0.000054   call s:Debug(1, DebugF, 'Entering(' . a:event . '): win = ' . winnr() . ', buf = ' . bufnr('%') . ' (' . bufname('%') . ')')
    2   0.000042   0.000019   call s:Debug(2, DebugF, 'w:BufKillList')
    2   0.000039   0.000017   call s:Debug(2, DebugF, 'w:BufKillColumnList')
    2   0.000039   0.000017   call s:Debug(2, DebugF, 'w:BufKillIndex')
    2              0.000010   if !exists('w:BufKillList')
                                " Just give up for now.
                                return
                              endif
    2              0.000019   let index = index(w:BufKillList, bufnr('%'))
    2              0.000006   if index != -1
                                " Extend list if required, then set the value
    2              0.000026     let w:BufKillColumnList += repeat([0], index - len(w:BufKillColumnList) + 1)
    2              0.000016     let w:BufKillColumnList[index] = col('.')
    2              0.000003   else
                                echom 'UpdateLastColumn failed to find bufnr ' . bufnr('%') . ' in w:BufKillList'
                              endif
    2   0.000043   0.000019   call s:Debug(2, DebugF, 'w:BufKillList')
    2   0.000039   0.000017   call s:Debug(2, DebugF, 'w:BufKillColumnList')
    2   0.000040   0.000018   call s:Debug(2, DebugF, 'w:BufKillIndex')
    2   0.000043   0.000020   call s:Debug(1, DebugF, 'Exiting (' . a:event . ')')
                              " redraw  " To hide call Debug messages for now!

FUNCTION  <SNR>161_write_buffer()
Called 1 time
Total time:   0.000123
 Self time:   0.000123

count  total (s)   self (s)
    1              0.000008   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    1              0.000004   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    1              0.000002   let fenc = getbufvar(a:bufnr, '&fileencoding')
    1              0.000001   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
                              endif
                            
    1              0.000002   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
                              endif
                            
    1              0.000098   call writefile(bufcontents, a:file)

FUNCTION  deoplete#util#rpcnotify()
Called 27 times
Total time:   0.004436
 Self time:   0.002805

count  total (s)   self (s)
   27   0.000315   0.000173   if !deoplete#init#_channel_initialized()
                                return ''
                              endif
                            
   27              0.000127   let a:context['rpc'] = a:event
                            
   27   0.001644   0.000155   if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:event, a:context)
                              else
   27              0.001860     call rpcnotify(g:deoplete#_channel_id, a:event, a:context)
   27              0.000041   endif
                            
   27              0.000039   return ''

FUNCTION  <SNR>310_InCommentAt()
Called 2 times
Total time:   0.000156
 Self time:   0.000156

count  total (s)   self (s)
    2              0.000155 	return synIDattr(synID(a:line, a:col, 0), 'name') =~ 'Comment\|String'

FUNCTION  ale#util#Mode()
Called 9 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    9              0.000028     return call('mode', a:000)

FUNCTION  205()
Called 84 times
Total time:   0.001736
 Self time:   0.001085

count  total (s)   self (s)
   84   0.001117   0.000466     let flags = self._flagsForScope(a:scope)
   84              0.000244     if index(flags, a:flag) == -1
   84              0.000234         call add(flags, a:flag)
   84              0.000064     end

FUNCTION  206()
Called 160 times
Total time:   0.000875
 Self time:   0.000875

count  total (s)   self (s)
  160              0.000812     let self._flags[a:scope] = []

FUNCTION  207()
Called 84 times
Total time:   0.000651
 Self time:   0.000651

count  total (s)   self (s)
   84              0.000240     if !has_key(self._flags, a:scope)
                                    let self._flags[a:scope] = []
                                endif
   84              0.000175     return self._flags[a:scope]

FUNCTION  ale#list#SetLists()
Called 1 time
Total time:   0.000036
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000005     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
                                else
    1   0.000024   0.000010         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    1              0.000001     endif

FUNCTION  ale#util#InSandbox()
Called 39 times
Total time:   0.000564
 Self time:   0.000535

count  total (s)   self (s)
   39              0.000064     try
   39   0.000261   0.000232         let &l:equalprg=&l:equalprg
   39              0.000047     catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
   39              0.000034     return 0

FUNCTION  airline#parts#crypt()
Called 213 times
Total time:   0.002332
 Self time:   0.002332

count  total (s)   self (s)
  213              0.002200   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  210()
Called 132 times
Total time:   0.001608
 Self time:   0.001608

count  total (s)   self (s)
  132              0.000147     let flagstring = ""
  264              0.000333     for i in values(self._flags)
  132              0.000298         let flagstring .= join(i)
  132              0.000068     endfor
                            
  132              0.000174     if len(flagstring) == 0
   48              0.000029         return ""
                                endif
                            
   84              0.000111     return '[' . flagstring . ']'

FUNCTION  216()
Called 4 times
Total time:   0.001138
 Self time:   0.000116

count  total (s)   self (s)
    4   0.000407   0.000031     call g:NERDTree.MustBeOpen()
    4   0.000725   0.000080     call nerdtree#exec(g:NERDTree.GetWinNum() . "wincmd w")

FUNCTION  <SNR>54_invoke_funcrefs()
Called 1 time
Total time:   0.010128
 Self time:   0.000087

count  total (s)   self (s)
    1   0.000078   0.000018   let builder = airline#builder#new(a:context)
    1   0.001883   0.000029   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    1              0.000003   if err == 1
    1   0.008143   0.000017     let a:context.line = builder.build()
    1              0.000005     let s:contexts[a:context.winnr] = a:context
    1              0.000012     call setwinvar(a:context.winnr, '&statusline', '%!airline#statusline('.a:context.winnr.')')
    1              0.000001   endif

FUNCTION  <SNR>51_abs_path()
Called 11 times
Total time:   0.000369
 Self time:   0.000369

count  total (s)   self (s)
   11              0.000332   let p = resolve(expand('#'.a:bufnr.':p'))
   11              0.000030   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>59_generate_names()
Called 217 times
Total time:   0.136108
 Self time:   0.136108

count  total (s)   self (s)
  217              0.000311   let names = []
  217              0.000266   let i = 1
  217              0.000444   let last_buffer = bufnr('$')
  217              0.000449   let current_buffer = bufnr('%')
 3038              0.003411   while i <= last_buffer
 2821              0.005806     if bufexists(i) && buflisted(i)
  868              0.001131       let modified = ' '
  868              0.003951       if getbufvar(i, '&mod')
  201              0.000359         let modified = g:bufferline_modified
  201              0.000105       endif
  868              0.003372       let fname = fnamemodify(bufname(i), g:bufferline_fname_mod)
  868              0.001149       if g:bufferline_pathshorten != 0
                                    let fname = pathshorten(fname)
                                  endif
  868              0.003284       let fname = substitute(fname, "%", "%%", "g")
                            
  868              0.000994       let skip = 0
 1736              0.001986       for ex in g:bufferline_excludes
  868              0.003143         if match(fname, ex) > -1
                                      let skip = 1
                                      break
                                    endif
  868              0.000615       endfor
                            
  868              0.000728       if !skip
  868              0.000935         let name = ''
  868              0.002440         if g:bufferline_show_bufnr != 0 && g:bufferline_status_info.count >= g:bufferline_show_bufnr
  868              0.001437           let name =  i . ':'
  868              0.000477         endif
  868              0.001956         let name .= fname . modified
                            
  868              0.001060         if current_buffer == i
  217              0.000943           let name = g:bufferline_active_buffer_left . name . g:bufferline_active_buffer_right
  217              0.000503           let g:bufferline_status_info.current = name
  217              0.000130         else
  651              0.001809           let name = g:bufferline_separator . name . g:bufferline_separator
  651              0.000343         endif
                            
  868              0.002254         call add(names, [i, name])
  868              0.000458       endif
  868              0.000432     endif
 2821              0.003217     let i += 1
 2821              0.001936   endwhile
                            
  217              0.000402   if len(names) > 1
  217              0.000294     if g:bufferline_rotate == 1
                                  call bufferline#algos#fixed_position#modify(names)
                                endif
  217              0.000131   endif
                            
  217              0.000241   return names

FUNCTION  ale#engine#FixLocList()
Called 1 time
Total time:   0.001116
 Self time:   0.001100

count  total (s)   self (s)
    1              0.000001     let l:bufnr_map = {}
    1              0.000001     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    1   0.000013   0.000007     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
   16              0.000013     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
   15              0.000145         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
   15              0.000013         if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
   15              0.000020         if has_key(l:old_item, 'code')
   15              0.000025             let l:item.code = l:old_item.code
   15              0.000007         endif
                            
   15              0.000034         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
   15              0.000019         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
   15              0.000019         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
                                    endif
                            
   15              0.000019         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
   15              0.000019         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
   15              0.000012         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
   15              0.000035         call add(l:new_loclist, l:item)
   15              0.000009     endfor
                            
    1   0.000015   0.000006     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    1              0.000002     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
    1              0.000001     return l:new_loclist

FUNCTION  222()
Called 13 times
Total time:   0.000966
 Self time:   0.000966

count  total (s)   self (s)
   13              0.000086     if exists("t:NERDTreeBufName")
   13              0.000860         return bufwinnr(t:NERDTreeBufName)
                                endif
                            
                                return -1

FUNCTION  223()
Called 9 times
Total time:   0.000808
 Self time:   0.000102

count  total (s)   self (s)
    9   0.000800   0.000094     return s:NERDTree.GetWinNum() != -1

FUNCTION  226()
Called 4 times
Total time:   0.000376
 Self time:   0.000061

count  total (s)   self (s)
    4   0.000347   0.000032     if !s:NERDTree.IsOpen()
                                    throw "NERDTree.TreeNotOpen"
                                endif

FUNCTION  228()
Called 404 times
Total time:   0.001688
 Self time:   0.001688

count  total (s)   self (s)
  404              0.000693     if !exists('s:NERDTree._PathFilters')
                                    let s:NERDTree._PathFilters = []
                                endif
  404              0.000318     return s:NERDTree._PathFilters

FUNCTION  <SNR>310_SetKeywords()
Called 4 times
Total time:   0.000130
 Self time:   0.000126

count  total (s)   self (s)
    4              0.000012 	let s:IsKeywordBak=&l:iskeyword
    4   0.000114   0.000110 	let &l:iskeyword='33-255'

FUNCTION  GitGutterGetHunkSummary()
Called 213 times
Total time:   0.004901
 Self time:   0.001092

count  total (s)   self (s)
  213   0.004813   0.001003   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  ale#highlight#SetHighlights()
Called 1 time
Total time:   0.000644
 Self time:   0.000034

count  total (s)   self (s)
    1              0.000020     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    1              0.000006     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    1   0.000616   0.000007     call ale#highlight#UpdateHighlights()

FUNCTION  ale#engine#SetResults()
Called 1 time
Total time:   0.004465
 Self time:   0.000093

count  total (s)   self (s)
    1   0.000013   0.000004     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    1              0.000001     if g:ale_set_signs
    1   0.003058   0.000015         call ale#sign#SetSigns(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000002     if g:ale_set_quickfix || g:ale_set_loclist
    1   0.000046   0.000010         call ale#list#SetLists(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000002     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
    1   0.000228   0.000008         call ale#statusline#Update(a:buffer, a:loclist)
    1              0.000001     endif
                            
    1              0.000001     if g:ale_set_highlights
    1   0.000651   0.000007         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    1              0.000000     endif
                            
    1              0.000001     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000014   0.000005             call ale#cursor#EchoCursorWarning()
    1              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000002         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000004         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.000394   0.000007         call ale#engine#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000034   0.000010         silent doautocmd <nomodeline> User ALELintPost
    1              0.000000     endif

FUNCTION  231()
Called 4 times
Total time:   0.045120
 Self time:   0.000024

count  total (s)   self (s)
    4   0.045116   0.000020     call self.ui.render()

FUNCTION  233()
Called 4 times
Total time:   0.000527
 Self time:   0.000507

count  total (s)   self (s)
    4   0.000026   0.000018     if self.getShowHelp()
                                    let help  = "\" NERDTree (" . nerdtree#version() . ") quickhelp~\n"
                                    let help .= "\" ============================\n"
                                    let help .= "\" File node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 3 ? "single" : "double") ."-click,\n"
                                    let help .= "\" <CR>,\n"
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in prev window\n"
                                    else
                                        let help .= "\" ". g:NERDTreeMapActivateNode .": open in current window\n"
                                    endif
                                    if self.nerdtree.isTabTree()
                                        let help .= "\" ". g:NERDTreeMapPreview .": preview\n"
                                    endif
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenSplit .": open split\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewSplit .": preview split\n"
                                    let help .= "\" ". g:NERDTreeMapOpenVSplit .": open vsplit\n"
                                    let help .= "\" ". g:NERDTreeMapPreviewVSplit .": preview vsplit\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Directory node mappings~\n"
                                    let help .= "\" ". (g:NERDTreeMouseMode ==# 1 ? "double" : "single") ."-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open & close node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenRecursively .": recursively open node\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapCloseDir .": close parent of node\n"
                                    let help .= "\" ". g:NERDTreeMapCloseChildren .": close all child nodes of\n"
                                    let help .= "\"    current node recursively\n"
                                    let help .= "\" middle-click,\n"
                                    let help .= "\" ". g:NERDTreeMapOpenExpl.": explore selected dir\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark table mappings~\n"
                                    let help .= "\" double-click,\n"
                                    let help .= "\" ". g:NERDTreeMapActivateNode .": open bookmark\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTab.": open in new tab\n"
                                    let help .= "\" ". g:NERDTreeMapOpenInTabSilent .": open in new tab silently\n"
                                    let help .= "\" ". g:NERDTreeMapDeleteBookmark .": delete bookmark\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree navigation mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapJumpRoot .": go to root\n"
                                    let help .= "\" ". g:NERDTreeMapJumpParent .": go to parent\n"
                                    let help .= "\" ". g:NERDTreeMapJumpFirstChild  .": go to first child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpLastChild   .": go to last child\n"
                                    let help .= "\" ". g:NERDTreeMapJumpNextSibling .": go to next sibling\n"
                                    let help .= "\" ". g:NERDTreeMapJumpPrevSibling .": go to prev sibling\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Filesystem mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapChangeRoot .": change tree root to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdir .": move tree root up a dir\n"
                                    let help .= "\" ". g:NERDTreeMapUpdirKeepOpen .": move tree root up a dir\n"
                                    let help .= "\"    but leave old root open\n"
                                    let help .= "\" ". g:NERDTreeMapRefresh .": refresh cursor dir\n"
                                    let help .= "\" ". g:NERDTreeMapRefreshRoot .": refresh current root\n"
                                    let help .= "\" ". g:NERDTreeMapMenu .": Show menu\n"
                                    let help .= "\" ". g:NERDTreeMapChdir .":change the CWD to the\n"
                                    let help .= "\"    selected dir\n"
                                    let help .= "\" ". g:NERDTreeMapCWD .":change tree root to CWD\n"
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Tree filtering mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapToggleHidden .": hidden files (" . (self.getShowHidden() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFilters .": file filters (" . (self.isIgnoreFilterEnabled() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleFiles .": files (" . (self.getShowFiles() ? "on" : "off") . ")\n"
                                    let help .= "\" ". g:NERDTreeMapToggleBookmarks .": bookmarks (" . (self.getShowBookmarks() ? "on" : "off") . ")\n"
                            
                                    " add quickhelp entries for each custom key map
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Custom mappings~\n"
                                    for i in g:NERDTreeKeyMap.All()
                                        if !empty(i.quickhelpText)
                                            let help .= "\" ". i.key .": ". i.quickhelpText ."\n"
                                        endif
                                    endfor
                            
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Other mappings~\n"
                                    let help .= "\" ". g:NERDTreeMapQuit .": Close the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapToggleZoom .": Zoom (maximize-minimize)\n"
                                    let help .= "\"    the NERDTree window\n"
                                    let help .= "\" ". g:NERDTreeMapHelp .": toggle help\n"
                                    let help .= "\"\n\" ----------------------------\n"
                                    let help .= "\" Bookmark commands~\n"
                                    let help .= "\" :Bookmark [<name>]\n"
                                    let help .= "\" :BookmarkToRoot <name>\n"
                                    let help .= "\" :RevealBookmark <name>\n"
                                    let help .= "\" :OpenBookmark <name>\n"
                                    let help .= "\" :ClearBookmarks [<names>]\n"
                                    let help .= "\" :ClearAllBookmarks\n"
                                    silent! put =help
                                elseif !self.isMinimal()
    4              0.000015         let help ="\" Press ". g:NERDTreeMapHelp ." for help\n"
    4              0.000033         silent! put =help
    4              0.000003     endif

FUNCTION  238()
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000010     return self._showBookmarks

FUNCTION  239()
Called 356 times
Total time:   0.000388
 Self time:   0.000388

count  total (s)   self (s)
  356              0.000303     return self._showFiles

FUNCTION  HtmlIndent()
Called 1 time
Total time:   0.001181
 Self time:   0.000454

count  total (s)   self (s)
                              "{{{
    1              0.000007   if prevnonblank(v:lnum - 1) < 1
                                " First non-blank line has no indent.
                                return 0
                              endif
                            
    1              0.000009   let curtext = tolower(getline(v:lnum))
    1              0.000005   let indentunit = shiftwidth()
                            
    1              0.000009   let b:hi_newstate = {}
    1              0.000007   let b:hi_newstate.lnum = v:lnum
                            
                              " When syntax HL is enabled, detect we are inside a tag.  Indenting inside
                              " a tag works very differently. Do not do this when the line starts with
                              " "<", it gets the "htmlTag" ID but we are not inside a tag then.
    1              0.000012   if curtext !~ '^\s*<'
    1              0.000030     normal! ^
    1              0.000031     let stack = synstack(v:lnum, col('.'))  " assumes there are no tabs
    1              0.000004     let foundHtmlString = 0
    1              0.000006     for synid in reverse(stack)
                                  let name = synIDattr(synid, "name")
                                  if index(b:hi_insideStringNames, name) >= 0
                                    let foundHtmlString = 1
                                  elseif index(b:hi_insideTagNames, name) >= 0
                                    " Yes, we are inside a tag.
                                    let indent = s:InsideTag(foundHtmlString)
                                    if indent >= 0
                                      " Do not keep the state. TODO: could keep the block type.
                                      let b:hi_indent.lnum = 0
                                      return indent
                                    endif
                                  endif
                                endfor
    1              0.000002   endif
                            
                              " does the line start with a closing tag?
    1              0.000015   let swendtag = match(curtext, '^\s*</') >= 0
                            
    1              0.000011   if prevnonblank(v:lnum - 1) == b:hi_indent.lnum && b:hi_lasttick == b:changedtick - 1
                                " use state (continue from previous line)
                              else
                                " start over (know nothing)
    1   0.000701   0.000033     let b:hi_indent = s:FreshState(v:lnum)
    1              0.000001   endif
                            
    1              0.000003   if b:hi_indent.block >= 2
                                " within block
                                let endtag = s:endtags[b:hi_indent.block]
                                let blockend = stridx(curtext, endtag)
                                if blockend >= 0
                                  " block ends here
                                  let b:hi_newstate.block = 0
                                  " calc indent for REST OF LINE (may start more blocks):
                                  call s:CountTagsAndState(strpart(curtext, blockend + strlen(endtag)))
                                  if swendtag && b:hi_indent.block != 5
                                    let indent = b:hi_indent.blocktagind + s:curind * indentunit
                                    let b:hi_newstate.baseindent = indent + s:nextrel * indentunit
                                  else
                                    let indent = s:Alien{b:hi_indent.block}()
                                    let b:hi_newstate.baseindent = b:hi_indent.blocktagind + s:nextrel * indentunit
                                  endif
                                else
                                  " block continues
                                  " indent this line with alien method
                                  let indent = s:Alien{b:hi_indent.block}()
                                endif
                              else
                                " not within a block - within usual html
    1              0.000006     let b:hi_newstate.block = b:hi_indent.block
    1              0.000002     if swendtag
                                  " The current line starts with an end tag, align with its start tag.
                                  call cursor(v:lnum, 1)
                                  let start_lnum = HtmlIndent_FindStartTag()
                                  if start_lnum > 0
                                    " check for the line starting with something inside a tag:
                                    " <sometag               <- align here
                                    "    attr=val><open>     not here
                                    let text = getline(start_lnum)
                                    let angle = matchstr(text, '[<>]')
                                    if angle == '>'
                                      call cursor(start_lnum, 1)
                                      normal! f>%
                                      let start_lnum = line('.')
                                      let text = getline(start_lnum)
                                    endif
                            
                                    let indent = indent(start_lnum)
                                    if col('.') > 2
                                      let swendtag = match(text, '^\s*</') >= 0
                                      call s:CountITags(text[: col('.') - 2])
                                      let indent += s:nextrel * shiftwidth()
                                      if !swendtag
                                        let indent += s:curind * shiftwidth()
                                      endif
                                    endif
                                  else
                                    " not sure what to do
                                    let indent = b:hi_indent.baseindent
                                  endif
                                  let b:hi_newstate.baseindent = indent
                                else
    1   0.000080   0.000019       call s:CountTagsAndState(curtext)
    1              0.000005       let indent = b:hi_indent.baseindent
    1              0.000008       let b:hi_newstate.baseindent = indent + (s:curind + s:nextrel) * indentunit
    1              0.000001     endif
    1              0.000001   endif
                            
    1              0.000004   let b:hi_lasttick = b:changedtick
    1              0.000014   call extend(b:hi_indent, b:hi_newstate, "force")
    1              0.000003   return indent

FUNCTION  gitgutter#diff#handler()
Called 1 time
Total time:   0.002029
 Self time:   0.000082

count  total (s)   self (s)
    1   0.000030   0.000004   call gitgutter#debug#log(a:diff)
                            
    1              0.000002   if !bufexists(a:bufnr)
                                return
                              endif
                            
    1   0.000238   0.000016   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    1   0.000507   0.000011   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    1              0.000002   let signs_count = len(modified_lines)
    1              0.000002   if signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
                              else
    1              0.000002     if g:gitgutter_signs || g:gitgutter_highlight_lines
    1   0.001194   0.000009       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    1              0.000001     endif
    1              0.000000   endif
                            
    1   0.000025   0.000007   call s:save_last_seen_change(a:bufnr)
    1              0.000013   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
                              endif

FUNCTION  ale#job#Stop()
Called 7 times
Total time:   0.000430
 Self time:   0.000430

count  total (s)   self (s)
    7              0.000024     if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
    7              0.000034     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
    7              0.000174         silent! call jobstop(a:job_id)
    7              0.000007     else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
                                endif

FUNCTION  240()
Called 4 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    4              0.000006     return self._showHelp

FUNCTION  241()
Called 404 times
Total time:   0.000434
 Self time:   0.000434

count  total (s)   self (s)
  404              0.000345     return self._showHidden

FUNCTION  244()
Called 404 times
Total time:   0.000444
 Self time:   0.000444

count  total (s)   self (s)
  404              0.000351     return self._ignoreEnabled == 1

FUNCTION  245()
Called 12 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
   12              0.000019     return g:NERDTreeMinimalUI

FUNCTION  <SNR>161_process_added()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000001   let offset = 0
    4              0.000004   while offset < a:to_count
    3              0.000004     let line_number = a:to_line + offset
    3              0.000006     call add(a:modifications, [line_number, 'added'])
    3              0.000003     let offset += 1
    3              0.000001   endwhile

FUNCTION  <SNR>310_Instack()
Called 2 times
Total time:   0.000151
 Self time:   0.000037

count  total (s)   self (s)
    2              0.000008 	exe 'let stack='.a:sname
    2   0.000060   0.000006 	call s:SetKeywords()
    2              0.000010 	let m=match(stack, '\<'.a:el.'\>')
    2   0.000066   0.000006 	call s:RestoreKeywords()
    2              0.000003 	if m < 0
    2              0.000001 		return 0
                            	else
                            		return 1
                            	endif

FUNCTION  deoplete#custom#_get()
Called 739 times
Total time:   0.006026
 Self time:   0.006026

count  total (s)   self (s)
  739              0.002097   if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
  739              0.000935   return s:custom

FUNCTION  remote#define#CommandBootstrap()
Called 1 time
Total time:   0.000645
 Self time:   0.000088

count  total (s)   self (s)
    1   0.000067   0.000019   let channel = remote#host#Require(a:host)
                            
    1              0.000002   if channel
    1   0.000474   0.000024     call remote#define#CommandOnChannel(channel, a:method, a:sync, a:name, a:opts)
    1   0.000088   0.000028     exe a:forward
    1              0.000001   else
                                exe 'delcommand '.a:name
                                echoerr 'Host "'a:host.'" is not available, deleting command "'.a:name.'"'
                              endif

FUNCTION  <SNR>81_UpdateList()
Called 2 times
Total time:   0.000202
 Self time:   0.000136

count  total (s)   self (s)
                              " Function to update the window list with info about the current buffer
    2              0.000003   let DebugF = 'UpdateList'
    2   0.000029   0.000018   call s:Debug(1, DebugF, 'Entering(' . a:event . '): win = ' . winnr() . ', buf = ' . bufnr('%') . ' (' . bufname('%') . ')')
    2              0.000004   if !exists('w:BufKillList')
                                let w:BufKillList = []
                              endif
    2              0.000003   if !exists('w:BufKillColumnList')
                                let w:BufKillColumnList = []
                              endif
    2              0.000003   if !exists('w:BufKillIndex')
                                let w:BufKillIndex = -1
                              endif
    2   0.000015   0.000006   call s:Debug(2, DebugF, 'w:BufKillList')
    2   0.000014   0.000006   call s:Debug(2, DebugF, 'w:BufKillColumnList')
    2   0.000013   0.000005   call s:Debug(2, DebugF, 'w:BufKillIndex')
    2              0.000004   let bufferNum = bufnr('%')
                            
    2              0.000006   if (w:BufKillIndex == -1) || (w:BufKillList[w:BufKillIndex] != bufferNum)
                                " Increment index
                                let w:BufKillIndex += 1
                                if w:BufKillIndex < len(w:BufKillList)
                                  " The branch is diverging, remove the end of the list
                                  call remove(w:BufKillList, w:BufKillIndex, -1)
                                  " Same for column list
                                  if w:BufKillIndex < len(w:BufKillColumnList)
                                    call remove(w:BufKillColumnList, w:BufKillIndex, -1)
                                  endif
                                endif
                                " Now remove any pre-existing instances of the buffer in the list
                                let existingIndex = index(w:BufKillList, bufferNum)
                                if existingIndex != -1
                                  call remove(w:BufKillList, existingIndex)
                                  let w:BufKillIndex -= 1
                                  if existingIndex < len(w:BufKillColumnList)
                                    call remove(w:BufKillColumnList, existingIndex)
                                  endif
                                endif
                                " Now add the buffer to the list, at the end
                                let w:BufKillList += [bufferNum]
                              endif
                            
    2   0.000015   0.000006   call s:Debug(2, DebugF, 'w:BufKillList')
    2   0.000013   0.000006   call s:Debug(2, DebugF, 'w:BufKillColumnList')
    2   0.000013   0.000005   call s:Debug(2, DebugF, 'w:BufKillIndex')
    2   0.000015   0.000008   call s:Debug(1, DebugF, 'Exiting (' . a:event . '): ', 'w:BufKillList')
                              " redraw  " To hide call Debug messages for now!

FUNCTION  gitgutter#hunk#reset()
Called 1 time
Total time:   0.000051
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000026   0.000007   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', [])
    1   0.000024   0.000006   call s:reset_summary(a:bufnr)

FUNCTION  ale#path#FindNearestFile()
Called 42 times
Total time:   0.005474
 Self time:   0.005474

count  total (s)   self (s)
   42              0.000678     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   42              0.000244     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   42              0.004067     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
   42              0.000099     if !empty(l:relative_path)
   21              0.000216         return fnamemodify(l:relative_path, ':p')
                                endif
                            
   21              0.000018     return ''

FUNCTION  ale#fix#ApplyQueuedFixes()
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002     let l:buffer = bufnr('')
    1              0.000004     let l:data = get(g:ale_fix_buffer_data, l:buffer, {'done': 0})
                            
    1              0.000001     if !l:data.done
    1              0.000001         return
                                endif
                            
                                call remove(g:ale_fix_buffer_data, l:buffer)
                            
                                if l:data.changes_made
                                    let l:start_line = len(l:data.output) + 1
                                    let l:end_line = len(l:data.lines_before)
                            
                                    if l:end_line >= l:start_line
                                        let l:save = winsaveview()
                                        silent execute l:start_line . ',' . l:end_line . 'd_'
                                        call winrestview(l:save)
                                    endif
                            
                                    " If the file is in DOS mode, we have to remove carriage returns from
                                    " the ends of lines before calling setline(), or we will see them
                                    " twice.
                                    let l:lines_to_set = getbufvar(l:buffer, '&fileformat') is# 'dos'   ? map(copy(l:data.output), 'substitute(v:val, ''\r\+$'', '''', '''')')   : l:data.output
                            
                                    call setline(1, l:lines_to_set)
                            
                                    if l:data.should_save
                                        if empty(&buftype)
                                            noautocmd :w!
                                        else
                                            set nomodified
                                        endif
                                    endif
                                endif
                            
                                if l:data.should_save
                                    let l:should_lint = g:ale_fix_on_save
                                else
                                    let l:should_lint = l:data.changes_made
                                endif
                            
                                silent doautocmd <nomodeline> User ALEFixPost
                            
                                " If ALE linting is enabled, check for problems with the file again after
                                " fixing problems.
                                if g:ale_enabled&& l:should_lint&& !ale#events#QuitRecently(l:buffer)
                                    call ale#Queue(0, l:data.should_save ? 'lint_file' : '')
                                endif

FUNCTION  <SNR>53_on_window_changed()
Called 13 times
Total time:   0.011234
 Self time:   0.000884

count  total (s)   self (s)
   13              0.000071   let s:active_winnr = winnr()
                            
   13              0.000056   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
                              endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
   13              0.000211   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
   13              0.000365   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
   12              0.000015     return
                              endif
    1              0.000012   let g:airline_last_window_changed = l:key
    1   0.000024   0.000017   call s:init()
    1   0.010361   0.000017   call airline#update_statusline()

FUNCTION  ale#history#Get()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000011     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>102_get_hunks_gitgutter()
Called 213 times
Total time:   0.008380
 Self time:   0.002271

count  total (s)   self (s)
  213   0.002332   0.001124   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
                                return ''
                              endif
  213   0.005651   0.000749   return GitGutterGetHunkSummary()

FUNCTION  <SNR>49_CursorHoldUpdate()
Called 5 times
Total time:   0.167543
 Self time:   0.000500

count  total (s)   self (s)
    5              0.000049     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
                                endif
                            
    5   0.000566   0.000073     if !g:NERDTree.IsOpen()
                                    return
                                endif
                            
                                " Do not update when a special buffer is selected
    5              0.000037     if !empty(&l:buftype)
    1              0.000001         return
                                endif
                            
    4              0.000034     let l:winnr = winnr()
    4              0.000021     let l:altwinnr = winnr('#')
                            
    4   0.001182   0.000044     call g:NERDTree.CursorToTreeWin()
    4   0.120311   0.000058     call b:NERDTree.root.refreshFlags()
    4   0.045180   0.000020     call NERDTreeRender()
                            
    4              0.000023     exec l:altwinnr . 'wincmd w'
    4              0.000035     exec l:winnr . 'wincmd w'

FUNCTION  261()
Called 160 times
Total time:   0.002143
 Self time:   0.002143

count  total (s)   self (s)
  160              0.000512     let newObj = copy(self)
  160              0.000348     let newObj.nerdtree = a:nerdtree
  160              0.000313     let newObj.subject = a:subject
  160              0.000316     let newObj.action = a:action
  160              0.000291     let newObj.params = a:params
  160              0.000179     return newObj

FUNCTION  263()
Called 160 times
Total time:   0.105490
 Self time:   0.004216

count  total (s)   self (s)
  160   0.003292   0.001149     let event = g:NERDTreeEvent.New(a:nerdtree, a:path, a:event, a:params)
                            
  320   0.003471   0.001121     for listener in s:Notifier.GetListenersForEvent(a:event)
  160   0.097834   0.001053         call {listener}(event)
  160              0.000156     endfor

FUNCTION  264()
Called 160 times
Total time:   0.001090
 Self time:   0.001090

count  total (s)   self (s)
  160              0.000454     if !exists("s:refreshListenersMap")
                                    let s:refreshListenersMap = {}
                                endif
  160              0.000212     return s:refreshListenersMap

FUNCTION  265()
Called 160 times
Total time:   0.002350
 Self time:   0.001259

count  total (s)   self (s)
  160   0.001820   0.000730     let listenersMap = s:Notifier.GetListenersMap()
  160              0.000450     return get(listenersMap, a:name, [])

FUNCTION  <SNR>99_is_excluded_window()
Called 1 time
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    1              0.000005   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
                              endfor
                            
    4              0.000011   for matchw in g:airline_exclude_filenames
    3              0.000042     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
                                endif
    3              0.000005   endfor
                            
    1              0.000004   if g:airline_exclude_preview && &previewwindow
                                return 1
                              endif
                            
    1              0.000002   return 0

FUNCTION  <SNR>162_highlight_name_for_change()
Called 5 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    5              0.000005   if a:text ==# 'added'
    2              0.000001     return 'GitGutterLineAdded'
                              elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
                              elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
                              elseif a:text ==# 'modified'
    2              0.000001     return 'GitGutterLineModified'
                              elseif a:text ==# 'modified_removed'
    1              0.000001     return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  ale#engine#GetLoclist()
Called 10 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
   10              0.000019     if !has_key(g:ale_buffer_info, a:buffer)
                                    return []
                                endif
                            
   10              0.000018     return g:ale_buffer_info[a:buffer].loclist

FUNCTION  airline#util#has_lawrencium()
Called 213 times
Total time:   0.000664
 Self time:   0.000664

count  total (s)   self (s)
  213              0.000573   return exists('*lawrencium#statusline')

FUNCTION  AutoPairsInsert()
Called 1 time
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
    1              0.000009   if !b:autopairs_enabled
                                return a:key
                              end
                            
    1              0.000008   let line = getline('.')
    1              0.000003   let pos = col('.') - 1
    1              0.000004   let before = strpart(line, 0, pos)
    1              0.000003   let after = strpart(line, pos)
    1              0.000008   let next_chars = split(after, '\zs')
    1              0.000004   let current_char = get(next_chars, 0, '')
    1              0.000002   let next_char = get(next_chars, 1, '')
    1              0.000020   let prev_chars = split(before, '\zs')
    1              0.000003   let prev_char = get(prev_chars, -1, '')
                            
    1              0.000001   let eol = 0
    1              0.000003   if col('$') -  col('.') <= 1
    1              0.000001     let eol = 1
    1              0.000001   end
                            
                              " Ignore auto close if prev character is \
    1              0.000001   if prev_char == '\'
                                return a:key
                              end
                            
                              " The key is difference open-pair, then it means only for ) ] } by default
    1              0.000004   if !has_key(b:AutoPairs, a:key)
                                let b:autopairs_saved_pair = [a:key, getpos('.')]
                            
                                " Skip the character if current character is the same as input
                                if current_char == a:key
                                  return s:Right
                                end
                            
                                if !g:AutoPairsFlyMode
                                  " Skip the character if next character is space
                                  if current_char == ' ' && next_char == a:key
                                    return s:Right.s:Right
                                  end
                            
                                  " Skip the character if closed pair is next character
                                  if current_char == ''
                                    if g:AutoPairsMultilineClose
                                      let next_lineno = line('.')+1
                                      let next_line = getline(nextnonblank(next_lineno))
                                      let next_char = matchstr(next_line, '\s*\zs.')
                                    else
                                      let next_char = matchstr(line, '\s*\zs.')
                                    end
                                    if next_char == a:key
                                      return "\<ESC>e^a"
                                    endif
                                  endif
                                endif
                            
                                " Fly Mode, and the key is closed-pairs, search closed-pair and jump
                                if g:AutoPairsFlyMode && has_key(b:AutoPairsClosedPairs, a:key)
                                  let n = stridx(after, a:key)
                                  if n != -1
                                    return repeat(s:Right, n+1)
                                  end
                                  if search(a:key, 'W')
                                    " force break the '.' when jump to different line
                                    return "\<Right>"
                                  endif
                                endif
                            
                                " Insert directly if the key is not an open key
                                return a:key
                              end
                            
    1              0.000002   let open = a:key
    1              0.000003   let close = b:AutoPairs[open]
                            
    1              0.000002   if current_char == close && open == close
                                return s:Right
                              end
                            
                              " Ignore auto close ' if follows a word
                              " MUST after closed check. 'hello|'
    1              0.000002   if a:key == "'" && prev_char =~ '\v\w'
                                return a:key
                              end
                            
                              " support for ''' ``` and """
    1              0.000002   if open == close
                                " The key must be ' " `
    1              0.000004     let pprev_char = line[col('.')-3]
    1              0.000002     if pprev_char == open && prev_char == open
                                  " Double pair found
                                  return repeat(a:key, 4) . repeat(s:Left, 3)
                                end
    1              0.000001   end
                            
    1              0.000002   let quotes_num = 0
                              " Ignore comment line for vim file
    1              0.000003   if &filetype == 'vim' && a:key == '"'
                                if before =~ '^\s*$'
                                  return a:key
                                end
                                if before =~ '^\s*"'
                                  let quotes_num = -1
                                end
                              end
                            
                              " Keep quote number is odd.
                              " Because quotes should be matched in the same line in most of situation
    1              0.000002   if g:AutoPairsSmartQuotes && open == close
                                " Remove \\ \" \'
    1              0.000010     let cleaned_line = substitute(line, '\v(\\.)', '', 'g')
    1              0.000002     let n = quotes_num
    1              0.000001     let pos = 0
    1              0.000002     while 1
    1              0.000004       let pos = stridx(cleaned_line, open, pos)
    1              0.000001       if pos == -1
    1              0.000001         break
                                  end
                                  let n = n + 1
                                  let pos = pos + 1
                                endwhile
    1              0.000001     if n % 2 == 1
                                  return a:key
                                endif
    1              0.000001   endif
                            
    1              0.000003   return open.close.s:Left

FUNCTION  270()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000007   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  272()
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000022   call add(self._sections, [a:group, a:contents])

FUNCTION  277()
Called 1 time
Total time:   0.008126
 Self time:   0.000651

count  total (s)   self (s)
    1              0.000003   let side = 1
    1              0.000002   let line = ''
    1              0.000003   let i = 0
    1              0.000006   let length = len(self._sections)
    1              0.000003   let split = 0
    1              0.000003   let is_empty = 0
    1              0.000003   let prev_group = ''
                            
    5              0.000011   while i < length
    4              0.000018     let section = self._sections[i]
    4              0.000014     let group = section[0]
    4              0.000014     let contents = section[1]
    4              0.000012     let pgroup = prev_group
    4   0.000125   0.000049     let prev_group = airline#builder#get_prev_group(self._sections, i)
    4              0.000021     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
                                elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
                                elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
                                endif
    4              0.000007     if is_empty
                                  let prev_group = pgroup
                                endif
    4   0.000141   0.000046     let is_empty = s:section_is_empty(self, contents)
                            
    4              0.000007     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
                                endif
                            
    4              0.000008     if group == ''
                                  let line .= contents
                                elseif group == '|'
    1              0.000001       let side = 0
    1              0.000002       let line .= contents
    1              0.000001       let split = 1
    1              0.000000     else
    3              0.000008       if prev_group == ''
    1              0.000006         let line .= '%#'.group.'#'
    1              0.000002       elseif split
                                    if !is_empty
                                      let line .= s:get_transitioned_seperator(self, prev_group, group, side)
                                    endif
                                    let split = 0
                                  else
    2              0.000004         if !is_empty
    2   0.007125   0.000033           let line .= s:get_seperator(self, prev_group, group, side)
    2              0.000002         endif
    2              0.000002       endif
    3   0.000261   0.000049       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
    3              0.000004     endif
                            
    4              0.000010     let i = i + 1
    4              0.000005   endwhile
                            
    1              0.000001   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
                              endif
    1              0.000001   return line

FUNCTION  ale#linter#GetExecutable()
Called 14 times
Total time:   0.004155
 Self time:   0.000186

count  total (s)   self (s)
   14   0.004135   0.000165     return has_key(a:linter, 'executable_callback')   ? ale#util#GetFunction(a:linter.executable_callback)(a:buffer)   : a:linter.executable

FUNCTION  <SNR>115_get_seperator()
Called 2 times
Total time:   0.007092
 Self time:   0.000074

count  total (s)   self (s)
    2   0.001820   0.000033   if airline#builder#should_change_group(a:prev_group, a:group)
    2   0.005269   0.000038     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  ale#util#GetFunction()
Called 51 times
Total time:   0.000482
 Self time:   0.000482

count  total (s)   self (s)
   51              0.000194     if type(a:string_or_ref) is v:t_string
   22              0.000069         return function(a:string_or_ref)
                                endif
                            
   29              0.000052     return a:string_or_ref

FUNCTION  airline#extensions#keymap#status()
Called 213 times
Total time:   0.002110
 Self time:   0.002110

count  total (s)   self (s)
  213              0.001001   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  213              0.000937     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  283()
Called 5 times
Total time:   0.000045
 Self time:   0.000034

count  total (s)   self (s)
    5   0.000032   0.000022     if !tagbar#is_paused() || a:force_current
    5              0.000009         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  ale#util#Tempname()
Called 7 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
    7              0.000014     let l:clear_tempdir = 0
                            
    7              0.000034     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
    7              0.000011     try
    7              0.000026         let l:name = tempname() " no-custom-checks
    7              0.000009     finally
    7              0.000009         if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
    7              0.000007     endtry
                            
    7              0.000009     return l:name

FUNCTION  <SNR>106_airline_ale_get_line_number()
Called 112 times
Total time:   0.000754
 Self time:   0.000697

count  total (s)   self (s)
  112              0.000107   if a:cnt == 0
  102              0.000063     return ''
                              endif
                            
   10              0.000016   let buffer       = bufnr('')
   10              0.000020   let problem_type = (a:type ==# 'error') ? 'E' : 'W'
   10   0.000116   0.000060   let problems     = copy(ale#engine#GetLoclist(buffer))
                            
   10              0.000237   call filter(problems, 'v:val.bufnr is buffer && v:val.type is# problem_type')
                            
   10              0.000013   if empty(problems)
                                return ''
                              endif
                            
   10              0.000027   let open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
   10              0.000028   let close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
   10              0.000028   return open_lnum_symbol . problems[0].lnum . close_lnum_symbol

FUNCTION  airline#extensions#hunks#get_hunks()
Called 213 times
Total time:   0.029717
 Self time:   0.016186

count  total (s)   self (s)
  213              0.000620   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
                              " Cache values, so that it isn't called too often
  213              0.002549   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && winwidth(0) == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes'
                                return b:airline_hunks
                              endif
  213   0.014516   0.000985   let hunks = s:get_hunks()
  213              0.000273   let string = ''
  213              0.000391   if !empty(hunks)
  852              0.001079     for i in [0, 1, 2]
  639              0.001774       if (s:non_zero_only == 0 && winwidth(0) > 100) || hunks[i] > 0
  639              0.003110         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  639              0.000393       endif
  639              0.000565     endfor
  213              0.000140   endif
  213              0.000411   let b:airline_hunks = string
  213              0.000436   let b:airline_changenr = b:changedtick
  213              0.000438   let s:airline_winwidth = winwidth(0)
  213              0.000230   return string

FUNCTION  <SNR>161_is_modified_and_removed()
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  <SNR>104_update_git_branch()
Called 213 times
Total time:   0.022113
 Self time:   0.004928

count  total (s)   self (s)
  213   0.001496   0.000772   if !airline#util#has_fugitive()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
                            
  213   0.018456   0.001996   let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  213              0.000723   if s:vcs_config['git'].branch is# 'master' && winwidth(0) < 81
                                " Shorten default a bit
                                let s:vcs_config['git'].branch='mas'
                              endif

FUNCTION  <SNR>177_TemporaryFilename()
Called 7 times
Total time:   0.000361
 Self time:   0.000186

count  total (s)   self (s)
    7              0.000028     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    7              0.000013     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    7   0.000258   0.000083     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  ale#sign#SetSigns()
Called 1 time
Total time:   0.003043
 Self time:   0.001502

count  total (s)   self (s)
    1              0.000002     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
    1   0.000306   0.000009     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    1   0.000152   0.000009     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    1   0.000157   0.000008     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    1   0.000710   0.000008     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    1   0.000259   0.000007     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    1              0.000002     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
   11              0.000016     for l:command in l:command_list
   10              0.001408         silent! execute l:command
   10              0.000010     endfor
                            
                                " Reset the sign column color when there are no more errors.
    1              0.000003     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  airline#extensions#ale#get_warning()
Called 213 times
Total time:   0.012417
 Self time:   0.001149

count  total (s)   self (s)
  213   0.012322   0.001055   return airline#extensions#ale#get('warning')

FUNCTION  remote#define#notify()
Called 1 time
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000007   if get(s:busy, a:chan, 0) > 0
                                let pending = get(s:pending_notifications, a:chan, [])
                                call add(pending, deepcopy(a:000))
                                let s:pending_notifications[a:chan] = pending
                              else
    1              0.000033     call call('rpcnotify', [a:chan] + a:000)
    1              0.000002   endif

FUNCTION  <SNR>119_can_diffoff()
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000039   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getbufvar(a:buf, 'git_dir')) && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  ale#sign#ReadSigns()
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000003     redir => l:output
    1              0.000019        silent execute 'sign place buffer=' . a:buffer
    1              0.000002     redir end
                            
    1              0.000006     return split(l:output, "\n")

FUNCTION  deoplete#custom#_get_buffer()
Called 1047 times
Total time:   0.008231
 Self time:   0.008231

count  total (s)   self (s)
 1047              0.002853   if !exists('b:custom')
                                call deoplete#custom#_init_buffer()
                              endif
                            
 1047              0.001313   return b:custom

FUNCTION  <SNR>111_create()
Called 1 time
Total time:   0.000407
 Self time:   0.000345

count  total (s)   self (s)
    1              0.000004   let _ = ''
    2              0.000012   for idx in range(len(a:parts))
    1   0.000032   0.000023     let part = airline#parts#get(a:parts[idx])
    1              0.000003     let val = ''
    1              0.000006     let add_sep = get(l:, 'add_sep', 0)
                            
    1              0.000005     if exists('part.function')
    1              0.000006       let func = (part.function).'()'
    1              0.000003     elseif exists('part.text')
                                  let func = '"'.(part.text).'"'
                                else
                                  if a:append > 0 && idx != 0
                                    let val .= s:spc.g:airline_left_alt_sep.s:spc
                                  endif
                                  if a:append < 0 && idx != 0
                                    let t = ''
                                    if !add_sep
                                      let t = s:spc.g:airline_right_alt_sep.s:spc
                                    endif
                                    let val = t.val
                                  endif
                                  if exists('part.raw')
                                    let _ .= s:wrap_accent(part, val.(part.raw))
                                    continue
                                  else
                                    let _ .= s:wrap_accent(part, val.a:parts[idx])
                                    continue
                                  endif
                                endif
                            
    1              0.000006     let minwidth = get(part, 'minwidth', 0)
                            
    1              0.000003     if a:append > 0 && idx != 0
                                  let partval = printf('%%{airline#util#append(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                elseif a:append < 0 && idx != len(a:parts) - 1
                                  let partval = printf('%%{airline#util#prepend(%s,%s)}', func, minwidth)
                                  " will add an extra separator, if minwidth is zero
                                  let add_sep = (minwidth == 0)
                                else
    1              0.000012       let partval = printf('%%{airline#util#wrap(%s,%s)}', func, minwidth)
    1              0.000003       let add_sep = 0
    1              0.000001     endif
                            
    1              0.000004     if exists('part.condition')
                                  let partval = substitute(partval, '{', '\="{".(part.condition)." ? "', '')
                                  let partval = substitute(partval, '}', ' : ""}', '')
                                endif
                            
    1   0.000072   0.000019     let val .= s:wrap_accent(part, partval)
    1              0.000005     let _ .= val
    1              0.000001   endfor
    1              0.000003   return _

FUNCTION  airline#builder#new()
Called 1 time
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000015   let builder = copy(s:prototype)
    1              0.000006   let builder._context = a:context
    1              0.000004   let builder._sections = []
                            
    1              0.000027   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    1              0.000003   return builder

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  245   0.499605   0.028659  airline#check_mode()
   10   0.463760   0.041846  airline#highlighter#highlight()
 1204   0.345775   0.077249  airline#highlighter#exec()
 1658   0.283432   0.128251  airline#highlighter#get_highlight()
   36   0.209736   0.047964  160()
    5   0.167543   0.000500  <SNR>49_CursorHoldUpdate()
  213   0.148440   0.003578  bufferline#refresh_status()
  219   0.147155   0.011046  bufferline#get_echo_string()
 3316   0.141432             <SNR>112_get_syn()
  225   0.138778   0.006777  <SNR>112_exec_separator()
  217   0.136108             <SNR>59_generate_names()
   36   0.122373   0.001905  <SNR>125_completion_begin()
  160   0.117375   0.001930  38()
  160   0.105490   0.004216  263()
  160   0.096782   0.003948  NERDTreeGitStatusRefreshListener()
   37   0.095754   0.077825  deoplete#init#_context()
  136   0.093918   0.089338  130()
  160   0.090222   0.012065  NERDTreeGetGitStatusPrefix()
   22   0.081190   0.001252  <SNR>125_completion_async()
  450   0.080381   0.002380  airline#themes#get_highlight()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 3316              0.141432  <SNR>112_get_syn()
  217              0.136108  <SNR>59_generate_names()
 1658   0.283432   0.128251  airline#highlighter#get_highlight()
  136   0.093918   0.089338  130()
   37   0.095754   0.077825  deoplete#init#_context()
 1204   0.345775   0.077249  airline#highlighter#exec()
   36   0.209736   0.047964  160()
   10   0.463760   0.041846  airline#highlighter#highlight()
    3   0.039634   0.033154  NERDTreeGitStatusRefresh()
 1204              0.030316  <SNR>112_CheckDefined()
  245   0.499605   0.028659  airline#check_mode()
  937              0.024233  <SNR>112_hl_group_exists()
  213   0.023597   0.020746  airline#extensions#whitespace#check()
  359   0.038008   0.020136  40()
   26   0.031354   0.019105  htmlcomplete#CompleteTags()
  213   0.029717   0.016186  airline#extensions#hunks#get_hunks()
   23              0.015798  <SNR>86_Highlight_Matching_Pair()
  213   0.017989   0.015196  <SNR>104_update_untracked()
  426   0.022082   0.014723  airline#extensions#ale#get()
 1491              0.013823  airline#util#append()

